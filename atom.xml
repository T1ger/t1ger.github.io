<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>t1ger的茶馆</title>
  <subtitle>头顶有光终是幻，足下生云未是仙</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://t1ger.github.io/"/>
  <updated>2017-08-24T09:41:50.895Z</updated>
  <id>https://t1ger.github.io/</id>
  
  <author>
    <name>t1ger</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go进阶04 函数闭包和不定参数</title>
    <link href="https://t1ger.github.io/2017/08/24/Go%E8%BF%9B%E9%98%B604-%E5%87%BD%E6%95%B0%E9%97%AD%E5%8C%85%E5%92%8C%E4%B8%8D%E5%AE%9A%E5%8F%82%E6%95%B0/"/>
    <id>https://t1ger.github.io/2017/08/24/Go进阶04-函数闭包和不定参数/</id>
    <published>2017-08-24T08:06:54.000Z</published>
    <updated>2017-08-24T09:41:50.895Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><p>匿名函数<br>在了解闭包之前,我们先说下什么是匿名函数,匿名函数由一个不带函数名的函数声明和函数体组成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">func (a, b int, z float64) bool &#123;</div><div class="line">    return a*b &lt; int(z)</div><div class="line">&#125;</div><div class="line"></div><div class="line">//匿名函数可以赋值给一个变量</div><div class="line">f := func(x, y int) int &#123;</div><div class="line">    return x + y</div><div class="line">&#125;</div><div class="line"></div><div class="line">func(ch chan int) &#123;</div><div class="line">    ch &lt;-ACK</div><div class="line">&#125;(reply_chan) //直接跟参数表示函数调用</div></pre></td></tr></table></figure>
</li>
<li><p>闭包<br>Go的匿名函数就是一个闭包,闭包是可以包含自由变量的代码块,这些变量不在这个代码块内或者任何全局上下文中定义,而是在定义代码块的环境中定义.<br>要执行的代码块(由于自由变量包含在代码块中,这些自由变量以及他们引用的对象没有被释放)为自由变量提供绑定的计算环境(作用域)</p>
<p>  Go语言中的闭包同样会引用到函数外的变量.闭包的实现确保只要闭包还被使用,那么被闭包引用的变量会一直存在</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    var j int = 5</div><div class="line">	</div><div class="line">	a := func()(func()) &#123;</div><div class="line">        var i int = 10</div><div class="line">        return func() &#123;</div><div class="line">            fmt.Printf(&quot;i, j: %d, %d\n&quot;, i, j)</div><div class="line">        &#125;</div><div class="line">    &#125;()</div><div class="line">    a()</div><div class="line">    j *= 2</div><div class="line">    a()</div><div class="line">&#125;</div><div class="line"></div><div class="line">[tiger@bogon tiger]$ go run closure.go </div><div class="line">i, j: 10, 5</div><div class="line">i, j: 10, 10</div></pre></td></tr></table></figure>
<p>  变量a指向的闭包函数引用了局部变量i和j, i的值被隔离,在闭包外不能被修改,改变j的值以后,再次调用a, 发现结构是修改过的值<br>在变量a指向的闭包函数中,只有内部的匿名函数才能访问变量i,而无法通过其他途径访问到,因此保证了i的安全性 </p>
</li>
<li><p>不定参数<br>不定参数是指函数接受传入的参数为不定数量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">func myfunc(args ...int)&#123;</div><div class="line">    for _, arg := range args&#123;</div><div class="line">        fmt.Println(arg)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//原样传递</div><div class="line">myfunc(args...)</div><div class="line">//传递片段</div><div class="line">myfunc(args[1:]...)</div><div class="line"></div><div class="line">myfunc(2, 4, 6)</div><div class="line">myfunc(1, 3, 4, 6)</div></pre></td></tr></table></figure>
<p>  如果传递的参数不是int,而是任意类型,可以指定类型为interface(),我们来看下Go语言标准库中fmt.Printf()的函数原型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func Printf(format string, args ...interface&#123;&#125;) &#123;</div><div class="line">// ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  下面代码是展示如何处理传入interface{}类型的参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">func MyPrintf(args ...interface&#123;&#125;) &#123;</div><div class="line">    for _, arg := range args &#123;</div><div class="line">	    switch arg.(type) &#123;</div><div class="line">            case int:</div><div class="line">                fmt.Println(arg, &quot;is an int value.&quot;)</div><div class="line">            case string:</div><div class="line">                fmt.Println(arg, &quot;is a string value.&quot;)</div><div class="line">            case int64:</div><div class="line">                fmt.Println(arg, &quot;is an int64 value.&quot;)</div><div class="line">            default:</div><div class="line">                fmt.Println(arg, &quot;is an unknow type.&quot;)</div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    var v1 int = 1</div><div class="line">    var v2 int64 = 234</div><div class="line">    var v3 string = &quot;hello&quot;</div><div class="line">    var v4 float32 = 1.456</div><div class="line">    MyPrintf(v1, v2, v3, v4)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>总结<br>匿名函数<br>闭包,Go的匿名函数就是一个闭包<br>不定参数</p>
</li>
</ul>
<hr>
<p>您的鼓励是我写作最大的动力</p>
<p>俗话说，投资效率是最好的投资。 如果您感觉我的文章质量不错，读后收获很大，预计能为您提高 10% 的工作效率，不妨小额捐助我一下，让我有动力继续写出更多好文章。</p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;匿名函数&lt;br&gt;在了解闭包之前,我们先说下什么是匿名函数,匿名函数由一个不带函数名的函数声明和函数体组成&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Go进阶03 Range</title>
    <link href="https://t1ger.github.io/2017/08/24/Go%E8%BF%9B%E9%98%B603-Range/"/>
    <id>https://t1ger.github.io/2017/08/24/Go进阶03-Range/</id>
    <published>2017-08-24T05:03:48.000Z</published>
    <updated>2017-08-24T06:57:16.618Z</updated>
    
    <content type="html"><![CDATA[<p>range 关键字用于for循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素。在数组和切片中它返回元素的索引值，在集合中返回 key-value 对的 key 值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot; </div><div class="line"></div><div class="line">func main() &#123;</div><div class="line"></div><div class="line">// range for slice</div><div class="line">    nums := []int&#123;2, 3, 4&#125;</div><div class="line">        sum := 0</div><div class="line">        for _, num := range nums &#123;</div><div class="line">            sum += num</div><div class="line">        &#125;</div><div class="line">    fmt.Println(&quot;sum: &quot;, sum)</div><div class="line">        for i, num := range nums &#123;</div><div class="line">             if num == 3 &#123;</div><div class="line">                 fmt.Println(&quot;index: &quot;, i)</div><div class="line">             &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">// range for map</div><div class="line">   mp := map[string]string&#123;&quot;1&quot;: &quot;apple&quot;, &quot;2&quot;:&quot;banan&quot;&#125;</div><div class="line">   for k, v := range mp &#123;</div><div class="line">       fmt.Printf(&quot;%s -- &gt; %s\n&quot;, k, v)</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">// range for channel</div><div class="line">    queue := make(chan string, 2)</div><div class="line">    queue &lt;- &quot;one&quot;</div><div class="line">    queue &lt;- &quot;two&quot;</div><div class="line">    close(queue)</div><div class="line">        </div><div class="line">    for v := range queue &#123;</div><div class="line">        fmt.Println(v)</div><div class="line">    &#125;</div><div class="line">   </div><div class="line">   </div><div class="line">//  range for enum Unicode string</div><div class="line">    for i, c := range &quot;go&quot; &#123;</div><div class="line">        fmt.Println(i, c)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[tiger@bogon tiger]$ go run range.go </div><div class="line">sum:  9</div><div class="line">index:  1</div><div class="line">1 -- &gt; apple</div><div class="line">2 -- &gt; banan</div><div class="line">one</div><div class="line">two</div><div class="line">0 103</div><div class="line">1 111</div></pre></td></tr></table></figure></p>
<p>总结<br>range 关键字用于for循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素.</p>
<hr>
<p>您的鼓励是我写作最大的动力</p>
<p>俗话说，投资效率是最好的投资。 如果您感觉我的文章质量不错，读后收获很大，预计能为您提高 10% 的工作效率，不妨小额捐助我一下，让我有动力继续写出更多好文章。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;range 关键字用于for循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素。在数组和切片中它返回元素的索引值，在集合中返回 key-value 对的 key 值&lt;/p&gt;
&lt;figure class=&quot;highlight pla
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Go进阶02 channel</title>
    <link href="https://t1ger.github.io/2017/08/24/Go%E8%BF%9B%E9%98%B602-channel/"/>
    <id>https://t1ger.github.io/2017/08/24/Go进阶02-channel/</id>
    <published>2017-08-24T03:21:33.000Z</published>
    <updated>2017-08-24T04:01:18.400Z</updated>
    
    <content type="html"><![CDATA[<p>在谈channel之前,我们先说下并发通信,在实践中,有两种最常见的并发通信模型:共享数据和消息,被共享的数据可能有多种形式,比如内存数据块、磁盘文件、网络数据等,一般内存共享最为常见.</p>
<p>Go语言选择消息机制作为通信方式.消息机制认为每个并发单元是自包含的、独立的个体，并且都有自己的变量，但在不同并发单元间这些变量不共享。每个并发单元的输入和输出只有一种，那就是消息。</p>
<p>Go语言提供的消息通信机制就被称为channel,channel是进程内的通信方式,golang channel 分为有缓冲与无缓冲两种类型,它们最大的区别是阻塞问题.不带缓冲的channel兼具通信和同步两种特性</p>
<ul>
<li><p>channel定义和操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">//一般channel声明</div><div class="line">var chanName chan ElementType</div><div class="line">var ch chan int</div><div class="line">var m map[string] chan bool</div><div class="line"></div><div class="line">//定义一个channel</div><div class="line">c := make(chan int)</div><div class="line"></div><div class="line">//定义一个带缓冲的channel</div><div class="line">c := make(chan int, 1024)</div><div class="line"></div><div class="line">//向一个channel发送一个值</div><div class="line">c &lt;- x</div><div class="line"></div><div class="line">//从channel中接收一个值</div><div class="line">&lt;- c</div><div class="line"></div><div class="line">//从channel c接收一个值并存储到x中</div><div class="line">x = &lt;-c </div><div class="line"></div><div class="line">//从channel接收一个值,如果channel关闭或者没数据,ok将为false</div><div class="line">x, ok = &lt;- c</div></pre></td></tr></table></figure>
</li>
<li><p>生产者消费者问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">    &quot;fmt&quot;</div><div class="line">    &quot;time&quot;</div><div class="line">)</div><div class="line"></div><div class="line">func producer(c chan int, max int) &#123;</div><div class="line">    for i :=0; i&lt; max;i++ &#123;</div><div class="line">        c &lt;- i</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">func consumer(c chan int) &#123;</div><div class="line">    ok := true</div><div class="line">	for ok &#123;</div><div class="line">	    if value, ok := &lt;-c; ok &#123;</div><div class="line">                fmt.Println(value)</div><div class="line">            &#125;</div><div class="line">       &#125;</div><div class="line">&#125; </div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    c := make(chan int)</div><div class="line">    defer close(c)    </div><div class="line">    go producer(c, 10)</div><div class="line">    go consumer(c)</div><div class="line">    time.Sleep(time.Millisecond * 10)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  执行结构将依次打印0-9</p>
</li>
<li><p>定时器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">    &quot;fmt&quot;</div><div class="line">    &quot;time&quot;</div><div class="line">)</div><div class="line"></div><div class="line">var mych = make(chan bool)</div><div class="line"></div><div class="line">func task() &#123;</div><div class="line">    fmt.Println(&quot;my timer task..&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func timer() &#123;</div><div class="line">    timeout := time.NewTicker(time.Millisecond * 1000)</div><div class="line">	select &#123;</div><div class="line">	case &lt;- mych:</div><div class="line">	    go task()</div><div class="line">	case &lt;-timeout.C:</div><div class="line">	    fmt.Println(&quot;Time out&quot;)</div><div class="line">	&#125;</div><div class="line">	fmt.Println(&quot;Hello go&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    timer()</div><div class="line">    time.Sleep(time.Millisecond * 10)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  这里没有向mychannel中写数据的，在等10秒之后会打印出hello go，程序并没有因此阻塞在这里</p>
</li>
<li><p>goroutine通信</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line">import (</div><div class="line">    &quot;fmt&quot;</div><div class="line">    &quot;time&quot;</div><div class="line">)</div><div class="line"></div><div class="line">var mych1 = make(chan int)</div><div class="line"></div><div class="line">func routine1() &#123;</div><div class="line">    for i:=0; i&lt; 10; i++ &#123;</div><div class="line">        mych1 &lt;- i</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">func routine2() &#123;</div><div class="line">    for &#123;</div><div class="line">        i := &lt;-mych1</div><div class="line">        fmt.Println(&quot;routine2: &quot;, i)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">func routine3() &#123;</div><div class="line">    for &#123;</div><div class="line">        i := &lt;-mych1</div><div class="line">        fmt.Println(&quot;routine3: &quot;, i)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    go routine1()</div><div class="line">    go routine2()</div><div class="line">    go routine3()</div><div class="line">    time.Sleep(time.Millisecond * 100)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  这里实现了一个goroutine写，两个goroutine读的过程，可以看到按顺序写进去的数据，被哪个goroutine读到是完全随机的，在golang中我们要实现进程间通信，channel是唯一途径，也是推荐的途径，它的底层是通过共享内存实现的</p>
</li>
<li><p>总结<br>channel定义和操作<br>生产者和消费者<br>goroutine通信,在使用channel的时候,至少有一个goroutine来负责读,否则你的程序就会阻塞在你写channel的地方</p>
</li>
</ul>
<hr>
<p>您的鼓励是我写作最大的动力</p>
<p>俗话说，投资效率是最好的投资。 如果您感觉我的文章质量不错，读后收获很大，预计能为您提高 10% 的工作效率，不妨小额捐助我一下，让我有动力继续写出更多好文章。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在谈channel之前,我们先说下并发通信,在实践中,有两种最常见的并发通信模型:共享数据和消息,被共享的数据可能有多种形式,比如内存数据块、磁盘文件、网络数据等,一般内存共享最为常见.&lt;/p&gt;
&lt;p&gt;Go语言选择消息机制作为通信方式.消息机制认为每个并发单元是自包含的、独
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Go进阶01 map</title>
    <link href="https://t1ger.github.io/2017/08/23/Go%E8%BF%9B%E9%98%B601-map/"/>
    <id>https://t1ger.github.io/2017/08/23/Go进阶01-map/</id>
    <published>2017-08-23T09:29:41.000Z</published>
    <updated>2017-08-23T10:34:03.046Z</updated>
    
    <content type="html"><![CDATA[<p>Map 是一种无序的键值对的集合</p>
<ul>
<li><p>定义map<br>可以使用内建函数 make 也可以使用 map 关键字来定义 Map:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 声明变量，默认 map 是 nil </div><div class="line">var map_variable map[key_data_type]value_data_type</div><div class="line"></div><div class="line">// 使用 make 函数 </div><div class="line">map_variable := make(map[key_data_type]value_data_type)</div></pre></td></tr></table></figure>
<p>  如果不初始化 map，那么就会创建一个 nil map。nil map 不能用来存放键值对</p>
</li>
<li><p>实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line"></div><div class="line">//new 进行创建</div><div class="line">    mapA := new(map[int]string)</div><div class="line">    *mapA = map[int]string&#123;&#125;</div><div class="line">    (*mapA)[112] = &quot;112&quot;</div><div class="line">    (*mapA)[110] = &quot;110&quot;</div><div class="line">	</div><div class="line">    for v := range *mapA &#123;</div><div class="line">        fmt.Println(v)</div><div class="line">	&#125;</div><div class="line">//直接创建</div><div class="line">    var map1 map[int]string = map[int]string&#123;&#125;</div><div class="line">    map2 := map[int]string&#123;</div><div class="line">        11:&quot;11&quot;</div><div class="line">        12:&quot;12&quot;</div><div class="line">	&#125;</div><div class="line">    fmt.Println(map2)</div><div class="line">    map1[1] = &quot;222&quot;</div><div class="line">    map1[2] = &quot;333&quot;</div><div class="line">    fmt.Println(map1)</div><div class="line">	</div><div class="line">//make 创建</div><div class="line">    map3 := make(map[int]string, 100)</div><div class="line">    map3[22] = &quot;22&quot;</div><div class="line">    fmt.Println(map3)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>map查找和删除<br>go提供内置函数delete(),参数为 map 和其对应的 key</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    var student map[string]string</div><div class="line">    student = make(map[string]string)</div><div class="line">    student[&quot;liming&quot;] = &quot;小明&quot;</div><div class="line">    student[&quot;hanmeimei&quot;] = &quot;小梅&quot;</div><div class="line">    </div><div class="line">    delete(student, &quot;liming&quot;)</div><div class="line">    liming, ok := student[&quot;liming&quot;]</div><div class="line">    if ok &#123;</div><div class="line">        fmt.Println(liming)</div><div class="line">    &#125; else &#123;</div><div class="line">        fmt.Println(&quot;no exist person&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>总结<br>map<br>delete()</p>
</li>
</ul>
<hr>
<p>您的鼓励是我写作最大的动力</p>
<p>俗话说，投资效率是最好的投资。 如果您感觉我的文章质量不错，读后收获很大，预计能为您提高 10% 的工作效率，不妨小额捐助我一下，让我有动力继续写出更多好文章。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Map 是一种无序的键值对的集合&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;定义map&lt;br&gt;可以使用内建函数 make 也可以使用 map 关键字来定义 Map:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;g
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Go基础08 面向对象的基本概念</title>
    <link href="https://t1ger.github.io/2017/08/23/Go%E5%9F%BA%E7%A1%8008-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>https://t1ger.github.io/2017/08/23/Go基础08-面向对象的基本概念/</id>
    <published>2017-08-23T07:11:22.000Z</published>
    <updated>2017-08-23T07:50:02.741Z</updated>
    
    <content type="html"><![CDATA[<p>Go里没有class关键字,通过使用struct和interface实现面向对象的思想.<br>在传统的面向对象语言中,class是基本单位,是数据成员和当前定义的所有操作,并对外提供公共方法让使用者操作对象.而且必须一开始就定义好了那些操作,不能开放式扩展.</p>
<ul>
<li><p>结构体<br>如果要某个符号对其它包访问,需要将该符合定义为以大写字母开头</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">type Human struct &#123;</div><div class="line">    name string</div><div class="line">    age  int</div><div class="line">    Height float64</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  一个Golang对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//定义一个Human类包含name和age</div><div class="line">type Human struct &#123;</div><div class="line">    name string</div><div class="line">    age  int</div><div class="line">&#125;</div><div class="line"></div><div class="line">//定义一个Men接口</div><div class="line">type Men interface &#123;</div><div class="line">    Say()</div><div class="line">&#125;</div><div class="line"></div><div class="line">//带接收参数的函数称为method</div><div class="line">func (h Human) Say() &#123;</div><div class="line">    fmt.Println(&quot;hello %s&quot;, h.name)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>组合<br>Golang里没有继承,是通过匿名组合来实现,没有传统的继承关系链,同时还能重用父类的方法和成员<br>来看下面的例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">type Base struct &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">func (b Base)show() &#123;</div><div class="line">    println(&quot;hello ws&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">type Child struct &#123;</div><div class="line">    Base</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    child := Child&#123;&#125;</div><div class="line">    child.Show()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>接口<br>Go语言中的接口是一系列操作定义的集合,不允许进行实现，而且也不能定义变量或者常量,这种非侵入式的设计，是为了解耦。接口和类本是不同的东西：类是把数据和代码包装在一起，是为了对内实现,接口则像是一种契约，是为了对外展示,Go语言中如果某个对象实现了这个接口的所有方法,那么就可以说这个对象实现了这个接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">type Interface interface &#123;</div><div class="line">    Len() int</div><div class="line">    Less(i, j int) bool</div><div class="line">    Swap(i, j int)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  空interface(interface{})不包含任何的method，正因为如此，所有的类型都实现了空interface。空interface对于描述起不到任何的作用(因为它不包含任何的method），但是空interface在我们需要存储任意类型的数值的时候相当有用，因为它可以存储任意类型的数值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var a interface&#123;&#125; //define a null interface</div><div class="line">var i int = 5</div><div class="line">s := &quot;Hello world&quot; </div><div class="line">a = int     // a 可以存储任意类型的数值</div><div class="line">a = s</div></pre></td></tr></table></figure>
<p>  一个函数把interface{}作为参数，那么他可以接受任意类型的值作为参数，如果一个函数返回interface{},那么也就可以返回任意类型的值</p>
</li>
<li><p>总结<br>struct是变量的集合<br>interface是方法的集合<br>struct与interface都支持匿名字段, 换言之, 支持组合实现继承<br>golang的struct与C++的class一样, 只能声明变量, 不能初始化</p>
</li>
</ul>
<hr>
<p>您的鼓励是我写作最大的动力</p>
<p>俗话说，投资效率是最好的投资。 如果您感觉我的文章质量不错，读后收获很大，预计能为您提高 10% 的工作效率，不妨小额捐助我一下，让我有动力继续写出更多好文章。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Go里没有class关键字,通过使用struct和interface实现面向对象的思想.&lt;br&gt;在传统的面向对象语言中,class是基本单位,是数据成员和当前定义的所有操作,并对外提供公共方法让使用者操作对象.而且必须一开始就定义好了那些操作,不能开放式扩展.&lt;/p&gt;
&lt;u
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Go基础07 函数</title>
    <link href="https://t1ger.github.io/2017/08/22/Go%E5%9F%BA%E7%A1%8007-%E5%87%BD%E6%95%B0/"/>
    <id>https://t1ger.github.io/2017/08/22/Go基础07-函数/</id>
    <published>2017-08-22T10:57:57.000Z</published>
    <updated>2017-08-23T03:16:14.697Z</updated>
    
    <content type="html"><![CDATA[<p>函数最重要的目的是方便我们重复使用相同的一段程序。</p>
<p>将一些操作隶属于一个函数，以后你想实现相同的操作的时候，只用调用函数名就可以，而不需要重复敲所有的语句。</p>
<ul>
<li><p>函数的定义<br>首先，我们要定义一个函数, 以说明这个函数的功能。<br>func function_name( [parameter_list] ) [return_types] {<br>  函数体<br>}<br>func：函数由 func 开始声明<br>function_name：函数名称，函数名和参数列表一起构成了函数签名<br>parameter list：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数<br>return_types：返回类型，函数返回一列值。return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的<br>函数体：函数定义的代码集合<br>下面来看个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">func sum(a, b int) int &#123;</div><div class="line">    var c int</div><div class="line">    c = a + b</div><div class="line">    return c</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  这个函数的功能是求两个数的和。</p>
</li>
<li><p>函数调用和参数传递<br>当创建函数时，你定义了函数需要做什么，通过调用改函数来执行指定任务。<br>调用函数，向函数传递参数，并返回值，例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    var a, b int = 3 ,5</div><div class="line">    var ret int</div><div class="line">    ret = sum(a, b)</div><div class="line">    fmt.Println(&quot;sum is %d&quot;, ret)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func sum(a, b int) int &#123;</div><div class="line">    var c int</div><div class="line">    c = a + b</div><div class="line">    return c</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>函数参数<br>值传递:值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。<br>引用传递:引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。<br>默认情况下，Go 语言使用的是值传递，即在调用过程中不会影响到实际参数。<br>不管是指针,引用类型还是其他类型参数,都是值拷贝传递.区别是拷贝的是对象本身还是拷贝指针</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    a := 100</div><div class="line">    p := &amp;a</div><div class="line">	</div><div class="line">    fmt.Printf(&quot;variable a pointer: %p, value: %d&quot;, &amp;a, a)</div><div class="line">    fmt.Printf(&quot;actual parameter p pointer: %p, value: %p&quot;, &amp;p, p&quot;)</div><div class="line">    show(p)</div><div class="line">&#125;	</div><div class="line">func show(x *int) &#123;</div><div class="line">    fmt.Printf(&quot;formal parameter x pointer: %p, value:%p&quot;, &amp;x, x)</div><div class="line">&#125;</div><div class="line"></div><div class="line">[tiger@bogon tiger]$ go run fun_add.go </div><div class="line">variable a pointer:0xc42000e258,value:100</div><div class="line">actual parameter p pointer: 0xc42000c028, value: 0xc42000e258</div><div class="line">formal parameter x pointer: 0xc42000c038, value:0xc42000e258</div></pre></td></tr></table></figure>
<p>  在调用函数时,新建立了x的内存,将参数p的值复制进去.这样x就保存了a的地址</p>
</li>
<li><p>总结<br>函数的目的： 提高程序的重复可用性。<br>练习:<br>写一个判断闰年的函数，参数为年、月、日。若是是闰年，返回True</p>
</li>
</ul>
<hr>
<p>您的鼓励是我写作最大的动力</p>
<p>俗话说，投资效率是最好的投资。 如果您感觉我的文章质量不错，读后收获很大，预计能为您提高 10% 的工作效率，不妨小额捐助我一下，让我有动力继续写出更多好文章。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;函数最重要的目的是方便我们重复使用相同的一段程序。&lt;/p&gt;
&lt;p&gt;将一些操作隶属于一个函数，以后你想实现相同的操作的时候，只用调用函数名就可以，而不需要重复敲所有的语句。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;函数的定义&lt;br&gt;首先，我们要定义一个函数, 以说明这个函数的功能。&lt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Go基础06 循环</title>
    <link href="https://t1ger.github.io/2017/08/22/Go%E5%9F%BA%E7%A1%8006-%E5%BE%AA%E7%8E%AF/"/>
    <id>https://t1ger.github.io/2017/08/22/Go基础06-循环/</id>
    <published>2017-08-22T10:23:37.000Z</published>
    <updated>2017-08-22T09:51:04.373Z</updated>
    
    <content type="html"><![CDATA[<p>循环用于重复执行一些程序块。</p>
<ul>
<li><p>for循环<br>for循环需要预先设定好循环的次数(n)，然后执行隶属于for的语句n次。<br>基本构造是<br>for init; condition; post { }<br>for condition { }<br>for { }<br>举例来说，我们编辑一个叫forDemo.py的文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    for a:=0; a&lt; 10; a++ &#123;</div><div class="line">        fmt.Println(&quot;a value is: %d&quot;, a)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>无限循环</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    for true &#123;</div><div class="line">        fmt.Println(&quot;this is for loop&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>中断循环<br>continue   // 在循环的某一次执行中，如果遇到continue, 那么跳过这一次执行，进行下一次的操作<br>break      // 停止执行整个循环<br>goto       //将控制转移到被标记的语句,这里不做过多介绍</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    for a:=0; a&lt; 10; a++ &#123;</div><div class="line">        if a == 2 &#123;</div><div class="line">            continue</div><div class="line">        &#125;</div><div class="line">    fmt.Println(&quot;a value is: %d&quot;, a)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  当循环执行到i = 2的时候，if条件成立，触发continue, 跳过本次执行(不执行print)，继续进行下一次执行(i = 3)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    for a:=0; a&lt; 10; a++ &#123;</div><div class="line">        if a == 2 &#123;</div><div class="line">            break</div><div class="line">        &#125;</div><div class="line">        fmt.Println(&quot;a value is: %d&quot;, a)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  当循环执行到i = 2的时候，if条件成立，触发break, 整个循环停止。</p>
</li>
<li><p>总结<br>for循环<br>break<br>continue</p>
</li>
</ul>
<hr>
<p>您的鼓励是我写作最大的动力</p>
<p>俗话说，投资效率是最好的投资。 如果您感觉我的文章质量不错，读后收获很大，预计能为您提高 10% 的工作效率，不妨小额捐助我一下，让我有动力继续写出更多好文章。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;循环用于重复执行一些程序块。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;for循环&lt;br&gt;for循环需要预先设定好循环的次数(n)，然后执行隶属于for的语句n次。&lt;br&gt;基本构造是&lt;br&gt;for init; condition; post { }&lt;br&gt;for condition 
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Go基础05 条件</title>
    <link href="https://t1ger.github.io/2017/08/22/Go%E5%9F%BA%E7%A1%8005-%E6%9D%A1%E4%BB%B6/"/>
    <id>https://t1ger.github.io/2017/08/22/Go基础05-条件/</id>
    <published>2017-08-22T08:38:14.000Z</published>
    <updated>2017-08-22T09:22:24.089Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><p>if语句<br>写一个完整的程序,命名为ifDemo.go.这个程序用于实现if结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    var  x, i int = 1, 1</div><div class="line">    if i &gt; 0 &#123;</div><div class="line">        fmt.Println(&quot;x=%d &quot;,x+1)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  复杂一些的if</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">package main </div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    var i int = 1       </div><div class="line">        if i&gt;0 &#123;</div><div class="line">            fmt.Println(&quot;positive i&quot;)</div><div class="line">                i++</div><div class="line">        &#125;else if i == 0 &#123;</div><div class="line">            fmt.Println(&quot;i is 0&quot;)</div><div class="line">                i = i*10</div><div class="line">        &#125;else &#123;</div><div class="line">            fmt.Println(&quot;negative i&quot;)</div><div class="line">                i--</div><div class="line">        &#125;</div><div class="line">        fmt.Println(&quot;new i: &quot;, i)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  这里有三个块,分别属于if, else if, else 程序根据条件，只执行三个分支中的一个</p>
<p>  整个if可以放在另一个if语句中，也就是if结构的嵌套使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    var i int = 5</div><div class="line">	if i &gt; 1 &#123;</div><div class="line">	    fmt.Println(&quot;i bigger than 1&quot;)</div><div class="line">		fmt.Println(&quot;good&quot;)</div><div class="line">		if i &gt;2 &#123;</div><div class="line">		    fmt.Println(&quot;i bigger than 2&quot;)</div><div class="line">			fmt.Println(&quot;even better&quot;)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>switch语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    var i int = 4</div><div class="line">    switch i &#123;</div><div class="line">        case 5: </div><div class="line">            fmt.Println(&quot;better&quot;)</div><div class="line">        case 3: </div><div class="line">            fmt.Println(&quot;good&quot;)</div><div class="line">        case 2:</div><div class="line">            fmt.Println(&quot;not bad&quot;)</div><div class="line">        default:</div><div class="line">            fmt.Println(&quot;bad&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>select语句<br>select 的代码形式和 switch 非常相似，不过 select 的 case 里的操作语句只能是[IO 操作]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    var c1, c2, c3 chan int</div><div class="line">    var a, b int</div><div class="line">    select &#123;</div><div class="line">        case a = &lt;-c1: </div><div class="line">            fmt.Println(&quot;receive %v from c1&quot;, a)</div><div class="line">        case c2 &lt;- b: </div><div class="line">            fmt.Println(&quot;send %v to c2&quot;, b)</div><div class="line">        default:</div><div class="line">            fmt.Println(&quot;not ready&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  代码执行到 select 时，case 语句会按照源代码的顺序被评估，且只评估一次，评估的结果会出现下面这几种情况<br>除 default 外，如果只有一个 case 语句评估通过，那么就执行这个case里的语句；<br>除 default 外，如果有多个 case 语句评估通过，那么通过伪随机的方式随机选一个；<br>如果 default 外的 case 语句都没有通过评估，那么执行 default 里的语句；<br>如果没有 default，那么 代码块会被阻塞，指导有一个 case 通过评估；否则一直阻塞<br>如果 case 语句中 的 receive 操作的对象是 nil channel，那么也会阻塞</p>
</li>
<li><p>总结<br>if 语句由一个布尔表达式后紧跟一个或多个语句组成,可以在 if 或 else if 语句中嵌入一个或多个 if 或 else if 语句<br>switch 语句用于基于不同条件执行不同动作。<br>select会随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行.如果 case 语句中 的 receive 操作的对象是 nil channel，那么也会阻塞</p>
</li>
</ul>
<hr>
<p>您的鼓励是我写作最大的动力</p>
<p>俗话说，投资效率是最好的投资。 如果您感觉我的文章质量不错，读后收获很大，预计能为您提高 10% 的工作效率，不妨小额捐助我一下，让我有动力继续写出更多好文章。</p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;if语句&lt;br&gt;写一个完整的程序,命名为ifDemo.go.这个程序用于实现if结构&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;li
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Go基础04 运算</title>
    <link href="https://t1ger.github.io/2017/08/22/Go%E5%9F%BA%E7%A1%8004-%E8%BF%90%E7%AE%97/"/>
    <id>https://t1ger.github.io/2017/08/22/Go基础04-运算/</id>
    <published>2017-08-22T07:57:40.000Z</published>
    <updated>2017-08-22T07:36:00.426Z</updated>
    
    <content type="html"><![CDATA[<p>Go的运算符和其他语言类似</p>
<p>（我们暂时只了解这些运算符的基本用法，方便我们展开后面的内容，高级应用暂时不介绍）</p>
<ul>
<li><p>数学运算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    var a int = 21</div><div class="line">	var b int = 10</div><div class="line">	var c int</div><div class="line">	</div><div class="line">	c= a + b</div><div class="line">	fmt.Println(&quot;a+b=%d &quot;,c)</div><div class="line">	c= a - b</div><div class="line">	fmt.Println(&quot;a-b=%d &quot;,c)</div><div class="line">	c= a * b</div><div class="line">	fmt.Println(&quot;a*b=%d &quot;,c)</div><div class="line">	c= a / b</div><div class="line">	fmt.Println(&quot;a/b=%d &quot;,c)</div><div class="line">        c = a % b</div><div class="line">	fmt.Println(&quot;a%b=%d &quot;,c)</div><div class="line">        a++</div><div class="line">	fmt.Println(&quot;a++=%d &quot;,a)</div><div class="line">	a--</div><div class="line">	fmt.Println(&quot;a++=%d &quot;,a)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>判断</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    var a int = 21</div><div class="line">    var b int = 10</div><div class="line">    fmt.Println(&quot;a==b is&quot;, a==b)</div><div class="line">    fmt.Println(&quot;a!=b is&quot;, a!=b)</div><div class="line">    fmt.Println(&quot;a&lt;b is&quot;, a&lt;b)</div><div class="line">    fmt.Println(&quot;a&lt;=b is&quot;, a&lt;=b)</div><div class="line">    fmt.Println(&quot;a&gt;b is&quot;, a&gt;b)</div><div class="line">    fmt.Println(&quot;a&gt;=b is&quot;, a&gt;=b)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>逻辑运算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    var a bool = true</div><div class="line">    var b bool = false     </div><div class="line">    fmt.Println(&quot;a&amp;&amp;b is&quot;, a&amp;&amp;b)</div><div class="line">    fmt.Println(&quot;a||b is&quot;, a||b)</div><div class="line">    fmt.Println(&quot;!(a&amp;&amp;b) is&quot;, !(a&amp;&amp;b))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>总结<br>数学 +, - , *, /, %, ++, –<br>判断 ==, !=, &gt;, &gt;=, &lt;, &lt;=<br>逻辑 &amp;&amp;, ||, !</p>
</li>
</ul>
<hr>
<p>您的鼓励是我写作最大的动力</p>
<p>俗话说，投资效率是最好的投资。 如果您感觉我的文章质量不错，读后收获很大，预计能为您提高 10% 的工作效率，不妨小额捐助我一下，让我有动力继续写出更多好文章。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Go的运算符和其他语言类似&lt;/p&gt;
&lt;p&gt;（我们暂时只了解这些运算符的基本用法，方便我们展开后面的内容，高级应用暂时不介绍）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;数学运算&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Go基础03数组和切片</title>
    <link href="https://t1ger.github.io/2017/08/21/Go%E5%9F%BA%E7%A1%8003%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/"/>
    <id>https://t1ger.github.io/2017/08/21/Go基础03数组和切片/</id>
    <published>2017-08-21T10:54:54.000Z</published>
    <updated>2017-08-22T06:56:32.329Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><p>数组<br>数组是一系列同一类型数据的集合.数组中包含的每个元素被称为数组元素,一个数组包含的元素个数称为数组的长度.数组长度在定义后就不能更改.<br>go数组的定义:<br>[32]byte<br>[2<em>N] struct {x, y int 32}<br>[1000]</em>float64<br>[3][5]int<br>[2][2][2]float64<br>go数组初始化:<br>初始化数组中 {} 中的元素个数不能大于 [] 中的数字<br>var balance = [5]float32{999.9, 3.0, 5.8, 8.9, 3.9}<br>如果忽略 [] 中的数字不设置数组大小，Go 语言会根据元素的个数来设置数组的大小：<br>var balance = […]float32{999.9, 3.0, 5.8, 8.9, 3.9}<br>go数组的完整操作:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    var n [10]int  // n 是一个长度为10的数组</div><div class="line">	var i,j int</div><div class="line">	</div><div class="line">	// 初始化数组元素</div><div class="line">	for i=0;i&lt;10;i++&#123;</div><div class="line">	    n[i]=i+100</div><div class="line">	&#125;</div><div class="line">    </div><div class="line">	//输出每个数组元素的值</div><div class="line">	for j=0;j&lt;10;j++ &#123;</div><div class="line">	    fmt.Printf(&quot;Element[%d] = %d\n&quot;, j, n[j] )</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>切片<br>切片是对数组的抽象,是在数组之上进行的一层封装,切片的长度不固定,可以追加元素.切片的容量即隐藏数组的长度。长度可变指的是在数组长度的范围内可变<br>go切片的定义:<br>var slice1 []type<br>var slice1 []type = make([]type, len)<br>slice1 := make([]type, len)<br>slice1 := make([]type, len, cap)<br>go切片初始化:<br>s := []int{1, 2, 3} //直接初始化切片，[]表示是切片类型，{1,2,3}初始化值依次是1,2,3.其cap=len=3<br>s := arr[:]  //初始化切片s,是数组arr的引用<br>s := arr[startIndex:endIndex] //将arr中从下标startIndex到endIndex-1 下的元素创建为一个新的切片<br>s := arr[startIndex:] //缺省endIndex时将表示一直到arr的最后一个元素<br>s := arr[:endIndex]  //缺省startIndex时将表示从arr的第一个元素开始<br>s1 := s[startIndex:endIndex] //通过切片s初始化切片s1<br>s :=make([]int,len,cap)  //通过内置函数make()初始化切片s,[]int 标识为其元素类型为int的切片<br>创建数组切片:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">   </div><div class="line">	var myArray [10]int = [10]int&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;  //定义一个数组</div><div class="line">	var mySlice []int = myArray[:5]</div><div class="line">	var mySlice1 []int  //一个切片在未初始化之前默认为 nil，长度为 0</div><div class="line">	</div><div class="line">	fmt.Println(&quot;Elements of myArray: &quot;)</div><div class="line">	for _,v := range myArray&#123;</div><div class="line">	    fmt.Print(v, &quot; &quot;)</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	fmt.Println(&quot;\nElements of mySlice: &quot;)</div><div class="line">	</div><div class="line">	//元素遍历</div><div class="line">	for _, v := range mySlice &#123;</div><div class="line">	    fmt.Print(v, &quot; &quot;)</div><div class="line">	&#125;</div><div class="line">	fmt.Println()</div><div class="line">	</div><div class="line">	//动态增加	</div><div class="line">	mySlice = append(mySlice, 1, 2, 3)</div><div class="line">	fmt.Println(mySlice)</div><div class="line">	</div><div class="line">	//内容复制</div><div class="line">	copy(mySlice, mySlice1)</div><div class="line">	fmt.Println(mySlice1)</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  关于动态追加,需要注意,如果定义 mySlice2 = []int{8, 9, 10} ,需要 mySlice = append(mySlice, mySlice2…)<br>mySlice2后的三个点表示把mySlice2包含的元素打散后传入,等同于 mySlice = append(mySlice, 7, 8, 9)</p>
</li>
<li><p>总结<br>数组定长,定义后不可更改.切片的长度不固定<br>数组的定义 初始化 遍历<br>切片的定义 初始化 遍历 增加 复制,空切片初始化之前默认为nil,长度为0</p>
</li>
</ul>
<hr>
<p>您的鼓励是我写作最大的动力</p>
<p>俗话说，投资效率是最好的投资。 如果您感觉我的文章质量不错，读后收获很大，预计能为您提高 10% 的工作效率，不妨小额捐助我一下，让我有动力继续写出更多好文章。</p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;数组&lt;br&gt;数组是一系列同一类型数据的集合.数组中包含的每个元素被称为数组元素,一个数组包含的元素个数称为数组的长度.数组长度在定义后就不能更改.&lt;br&gt;go数组的定义:&lt;br&gt;[32]byte&lt;br&gt;[2&lt;em&gt;N] struct {x, y int 3
    
    </summary>
    
    
  </entry>
  
</feed>
