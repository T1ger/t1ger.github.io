<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>t1ger的茶馆</title>
  <subtitle>头顶有光终是幻，足下生云未是仙</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://t1ger.github.io/"/>
  <updated>2017-12-15T06:37:32.642Z</updated>
  <id>https://t1ger.github.io/</id>
  
  <author>
    <name>t1ger</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HDFS Short-Circuit Local Reads</title>
    <link href="https://t1ger.github.io/2017/12/15/HDFS-Short-Circuit-Local-Reads/"/>
    <id>https://t1ger.github.io/2017/12/15/HDFS-Short-Circuit-Local-Reads/</id>
    <published>2017-12-15T02:14:40.000Z</published>
    <updated>2017-12-15T06:37:32.642Z</updated>
    
    <content type="html"><![CDATA[<h5 id="Background"><a href="#Background" class="headerlink" title="Background"></a><b>Background</b></h5><p>In HDFS, reads normally go through the DataNode. Thus, when the client asks the DataNode to read a file, the DataNode reads that file off of the disk and sends the data to the client over a TCP socket. So-called “short-circuit” reads bypass the DataNode, allowing the client to read the file directly. Obviously, this is only possible in cases where the client is co-located with the data. Short-circuit reads provide a substantial performance boost to many applications</p>
<h5 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a><b>Setup</b></h5><p>To configure short-circuit local reads, you will need to enable libhadoop.so. See <a href="https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/NativeLibraries.html" target="_blank" rel="external">Native Libraries</a> for details on enabling this library. if you don’t compile yourself, may be use complile binary version ,see <a href="http://dl.bintray.com/sequenceiq/sequenceiq-bin/" target="_blank" rel="external">here</a><br>Short-circuit reads make use of a UNIX domain socket. This is a special path in the filesystem that allows the client and the DataNodes to communicate. You will need to set a path to this socket. The DataNode needs to be able to create this path. On the other hand, it should not be possible for any user except the HDFS user or root to create this path. For this reason, paths under /var/run or /var/lib are often used.</p>
<p>The client and the DataNode exchange information via a shared memory segment on /dev/shm.</p>
<p>Short-circuit local reads need to be configured on both the DataNode and the client.</p>
<p>Java can not use Unix Domain Socket directly，so you need install Hadoop native package libhadoop.so。if you use Pivotal HD，CDH and so on, native package will be install at you install hadoop package. you can use command to check native package like this</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ hadoop checknative</div><div class="line">hadoop: true /usr/lib/hadoop/lib/native/libhadoop.so.1.0.0</div><div class="line">zlib:   true /lib64/libz.so.1</div><div class="line">snappy: true /usr/lib64/libsnappy.so.1</div><div class="line">lz4:    true revision:99</div><div class="line">bzip2:  true /lib64/libbz2.so.1</div></pre></td></tr></table></figure>
<p>#打开short-circuit local reads 功能</p>
<p>dfs.client.read.shortcircuit:  false </p>
<p>#可选。该参数是一个指向UNIX域套接字的路径，用于DataNode和本地HDFS客户端通信。如果在该路径中出现了字符串”_PORT”，会被替换成DataNode的TCP端口。</p>
<p>dfs.domain.socket.path: </p>
<p>#设置了该参数，short-circuit local reads功能将跳过checksums校验。通常不推荐这么做，但是该参数对于特殊场合可能有用。如果你在HDFS之外自己做checksum校验，那么就该考虑设置该参数。</p>
<p>dfs.client.read.shortcircuit.skip.checksum: false</p>
<p>#DFSClient维护着一个用于保存最近已打开的文件描述符的缓存。该参数控制着此缓存的容量。增大该缓存的容量就可以使用更多文件描述符，但是，在涉及大量seek操作的负载上可能带来更好的性能</p>
<p>dfs.client.read.shortcircuit.streams.cache.size: 256</p>
<p>#该参数控制着文件描述符因为长期不活跃而被关闭之前需要在客户端缓存上下文中驻留的最小时间</p>
<p>dfs.client.read.shortcircuit.streams.cache.expiry.ms: 300000</p>
<h5 id="Example-Configuration"><a href="#Example-Configuration" class="headerlink" title="Example Configuration"></a><b>Example Configuration</b></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;configuration&gt;</div><div class="line">  &lt;property&gt;</div><div class="line">    &lt;name&gt;dfs.client.read.shortcircuit&lt;/name&gt;</div><div class="line">    &lt;value&gt;true&lt;/value&gt;</div><div class="line">  &lt;/property&gt;</div><div class="line">  &lt;property&gt;</div><div class="line">    &lt;name&gt;dfs.domain.socket.path&lt;/name&gt;</div><div class="line">    &lt;value&gt;/var/lib/hadoop-hdfs/dn_socket&lt;/value&gt;</div><div class="line">  &lt;/property&gt;</div><div class="line">&lt;/configuration&gt;</div></pre></td></tr></table></figure>
<h5 id="Legacy-HDFS-Short-Circuit-Local-Reads"><a href="#Legacy-HDFS-Short-Circuit-Local-Reads" class="headerlink" title="Legacy HDFS Short-Circuit Local Reads"></a><b>Legacy HDFS Short-Circuit Local Reads</b></h5><p>Legacy implementation of short-circuit local reads on which the clients directly open the HDFS block files is still available for platforms other than the Linux. Setting the value of dfs.client.use.legacy.blockreader.local in addition to dfs.client.read.shortcircuit to true enables this feature.</p>
<p>You also need to set the value of dfs.datanode.data.dir.perm to 750 instead of the default 700 and chmod/chown the directory tree under dfs.datanode.data.dir as readable to the client and the DataNode. You must take caution because this means that the client can read all of the block files bypassing HDFS permission.</p>
<p>Because Legacy short-circuit local reads is insecure, access to this feature is limited to the users listed in the value of dfs.block.local-path-access.user.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;configuration&gt;</div><div class="line">  &lt;property&gt;</div><div class="line">    &lt;name&gt;dfs.client.read.shortcircuit&lt;/name&gt;</div><div class="line">    &lt;value&gt;true&lt;/value&gt;</div><div class="line">  &lt;/property&gt;</div><div class="line">  &lt;property&gt;</div><div class="line">    &lt;name&gt;dfs.client.use.legacy.blockreader.local&lt;/name&gt;</div><div class="line">    &lt;value&gt;true&lt;/value&gt;</div><div class="line">  &lt;/property&gt;</div><div class="line">  &lt;property&gt;</div><div class="line">    &lt;name&gt;dfs.datanode.data.dir.perm&lt;/name&gt;</div><div class="line">    &lt;value&gt;750&lt;/value&gt;</div><div class="line">  &lt;/property&gt;</div><div class="line">  &lt;property&gt;</div><div class="line">    &lt;name&gt;dfs.block.local-path-access.user&lt;/name&gt;</div><div class="line">    &lt;value&gt;foo,bar&lt;/value&gt;</div><div class="line">  &lt;/property&gt;</div><div class="line">&lt;/configuration&gt;</div></pre></td></tr></table></figure>
<p>ref<br><a href="https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/ShortCircuitLocalReads.html" target="_blank" rel="external">Short-Circuit Local Reads</a><br><a href="https://www.zybuluo.com/jewes/note/37713" target="_blank" rel="external">详解HDFS Short Circuit Local Reads</a><br><a href="http://blog.csdn.net/jack85986370/article/details/51902871" target="_blank" rel="external">Unable to load native-hadoop library for your platform</a></p>
<hr>
<p>您的鼓励是我写作最大的动力</p>
<p>俗话说，投资效率是最好的投资。 如果您感觉我的文章质量不错，读后收获很大，预计能为您提高 10% 的工作效率，不妨小额捐助我一下，让我有动力继续写出更多好文章。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;Background&quot;&gt;&lt;a href=&quot;#Background&quot; class=&quot;headerlink&quot; title=&quot;Background&quot;&gt;&lt;/a&gt;&lt;b&gt;Background&lt;/b&gt;&lt;/h5&gt;&lt;p&gt;In HDFS, reads normally go thro
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>how to migrate Gitlab to a new server</title>
    <link href="https://t1ger.github.io/2017/12/13/how-to-migrate-Gitlab-to-a-new-server/"/>
    <id>https://t1ger.github.io/2017/12/13/how-to-migrate-Gitlab-to-a-new-server/</id>
    <published>2017-12-13T07:05:49.000Z</published>
    <updated>2017-12-13T08:35:53.640Z</updated>
    
    <content type="html"><![CDATA[<p>gitlab安装有三种方法: docker、yum 、源码,本文环境是yum安装方式<br>1.确认旧gitlab版本信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo gitlab-rake gitlab:env:info</div></pre></td></tr></table></figure></p>
<p>注意: 新服务版本要求保持一致,否则无法导入,如果版本比较旧,需要升级旧版本服务器或新服务版本降级后在升级<br>旧服务器升级也比较简单<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#stop some service</div><div class="line">sudo gitlab-ctl stop unicorn</div><div class="line">sudo gitlab-ctl stop sidekiq</div><div class="line">sudo gitlab-ctl stop nginx</div><div class="line">#update</div><div class="line">sudo yum update gitlab-ce</div><div class="line">sudo gitlab-ctl reconfigure</div><div class="line">sudo gitlab-ctl restart</div></pre></td></tr></table></figure></p>
<p>2.备份配置文件和数据<br>将 /etc/gitlab/gitlab.rb 和 gitlab-secrets.json 拷贝到新服务对应目录<br>注意,我旧环境是用了自带的nginx,新环境用了机器上已经存在的nginx</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#disable nginx service</div><div class="line">vi /etc/gitlab/gitlab.rb...#设置nginx为false,关闭自带Nginxnginx[‘enable‘] = false...</div><div class="line"></div><div class="line">#check nginx config,migrate to new nginx</div><div class="line">/var/opt/gitlab/nginx/conf/nginx.conf  </div><div class="line">/var/opt/gitlab/nginx/conf/gitlab-http.conf</div><div class="line">/var/opt/gitlab/nginx/conf/nginx-status.conf</div><div class="line"></div><div class="line">#restart service</div><div class="line">sudo gitlab-ctl reconfigure</div><div class="line">sudo service nginx restart</div></pre></td></tr></table></figure>
<p>备份旧机器git数据,同时拷贝到新服务上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#backup gitlab to  /var/opt/gitlab/backups</div><div class="line">gitlab-rake gitlab:backup:create</div></pre></td></tr></table></figure></p>
<p>在新机器上恢复数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gitlab-rake gitlab:backup:restore RAILS_ENV=production   BACKUP=1513135372_2017_12_13</div></pre></td></tr></table></figure></p>
<p>如果新机器数据不全,可以把／var/opt/gitlab/git-data拷贝过去</p>
<p>3.迁移遇到的问题</p>
<ul>
<li><p>在新机器执行gitlab-ctl reconfigure,查看进程ps -ef|grep nginx</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">root 11485 0.0 0.0 1836 608 ? Ss Mar18 0:02 runsvdir -P /opt/gitlab/service log: </div><div class="line">…..runsv nginx: warning: unable to open supervise/stat.new: </div><div class="line">file does not exist runsv nginx: warning: unable to open supervise/stat.new:</div><div class="line">file does not exist runsv nginx: warning: unable to open supervise/pid.new: </div><div class="line">file does not exist runsv nginx: warning: unable to open log/supervise/pid.new:</div><div class="line">file does not exist runsv nginx: warning: unable to open log/supervise/pid.new:</div><div class="line">file does not exist</div></pre></td></tr></table></figure>
<p>  解决方法: 重启系统解决</p>
</li>
<li><p>查看nginx日志报错</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2017/12/13 13:19:00 [crit] 2436#0: *2 connect() to unix:/var/opt/gitlab/gitlab-workhorse/socket failed (13: Permission denied) while connecting to upstream, client: 119.6.3.75, server: gitlab.weishao.com.cn, request: &quot;GET /index.html HTTP/1.1&quot;, upstream: &quot;http://unix:/var/opt/gitlab/gitlab-workhorse/socket:/index.html&quot;, host: &quot;59.110.114.10&quot;</div></pre></td></tr></table></figure>
<p>  解决方法: 由于旧服务nginx使用git启动nginx,新服务器用nobody用户运行nginx,我们通过修改 /etc/gitlab/gitlab.rb文件解决</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">##! When bundled nginx is disabled we need to add the external webserver user to</div><div class="line">##! the GitLab webserver group.</div><div class="line">web_server[&apos;external_users&apos;] = [&apos;nobody&apos;]</div><div class="line">web_server[&apos;username&apos;] = &apos;nobody&apos;</div><div class="line">web_server[&apos;group&apos;] = &apos;nobody&apos;</div><div class="line">web_server[&apos;uid&apos;] = 99</div><div class="line">web_server[&apos;gid&apos;] = 99</div><div class="line">web_server[&apos;shell&apos;] = &apos;/bin/false&apos;</div><div class="line">web_server[&apos;home&apos;] = &apos;/var/opt/gitlab/nginx&apos;</div><div class="line"></div><div class="line">sudo gitlab-ctl reconfigure</div></pre></td></tr></table></figure>
<p>  也可以将nginx运行账号添加到gitlab-www组中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo usermod -a -G gitlab-www nobody</div><div class="line">sudo service nginx restart</div></pre></td></tr></table></figure>
<p>  但是执行sudo gitlab-ctl reconfigure后需要重新执行</p>
</li>
</ul>
<p>ref<br><a href="http://blog.pzxbc.com/2016/03/22/gitlab-install-configure/" target="_blank" rel="external">Gitlab安装配置及使用</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;gitlab安装有三种方法: docker、yum 、源码,本文环境是yum安装方式&lt;br&gt;1.确认旧gitlab版本信息&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div 
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Deploy Elasticsearch</title>
    <link href="https://t1ger.github.io/2017/11/20/Deploy-Elasticsearch/"/>
    <id>https://t1ger.github.io/2017/11/20/Deploy-Elasticsearch/</id>
    <published>2017-11-20T08:31:50.000Z</published>
    <updated>2017-11-21T09:33:58.393Z</updated>
    
    <content type="html"><![CDATA[<h5 id="ElasticSearch-deploy-doc"><a href="#ElasticSearch-deploy-doc" class="headerlink" title="ElasticSearch deploy doc"></a><b>ElasticSearch deploy doc</b></h5><ul>
<li><p>env</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# cat /etc/issue</div><div class="line">CentOS release 6.8 (Final)</div><div class="line">Kernel \r on an \m</div><div class="line"></div><div class="line">[root@localhost ~]# java -version</div><div class="line">java version &quot;1.8.0_112&quot;</div><div class="line">Java(TM) SE Runtime Environment (build 1.8.0_112-b15)</div><div class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.112-b15, mixed mode)</div></pre></td></tr></table></figure>
</li>
<li><p>download es, create es user </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">curl -L -O  https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.0.0.tar.gz</div><div class="line"></div><div class="line">tar -xzf elasticsearch-6.0.0.tar.gz</div><div class="line">sudo useradd es</div><div class="line">mv elasticsearch-6.0.0 /usr/local/elasticsearch</div><div class="line">chown es.es /usr/local/elasticsearch -R</div><div class="line"></div><div class="line">#add es.conf to  /etc/security/limits.d/es.conf</div><div class="line">[root@localhost ~]# cat  /etc/security/limits.d/es.conf</div><div class="line">es soft memlock unlimited</div><div class="line">es hard memlock unlimited</div><div class="line">es soft nofile 204800</div><div class="line">es hard nofile 204800</div><div class="line">es soft nproc  4096</div><div class="line"></div><div class="line">#add option to /etc/sysctl.conf</div><div class="line">vm.max_map_count=655360</div><div class="line">sysctl -p</div></pre></td></tr></table></figure>
</li>
<li><p>conf</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# cat /usr/local/elasticsearch/config/elasticsearch.yml |grep -v ^#</div><div class="line">cluster.name: es-ws-v6</div><div class="line">node.name: node-1</div><div class="line">node.master: true</div><div class="line">node.data: true</div><div class="line">path.data: /usr/local/elasticsearch/data</div><div class="line">path.logs: /usr/local/elasticsearch/logs</div><div class="line">bootstrap.memory_lock: true</div><div class="line">bootstrap.system_call_filter: false</div><div class="line">network.host: 172.16.56.193</div><div class="line">network.publish_host: 172.16.56.193</div><div class="line">discovery.zen.ping.unicast.hosts: [&quot;172.16.56.194&quot;,&quot;172.16.56.195&quot;]</div><div class="line">discovery.zen.minimum_master_nodes: 2</div><div class="line"></div><div class="line"></div><div class="line">[root@localhost ~]# cat /usr/local/elasticsearch/config/elasticsearch.yml |grep -v ^#</div><div class="line">cluster.name: es-ws-v6</div><div class="line">node.name: node-2</div><div class="line">node.master: true</div><div class="line">node.data: true</div><div class="line">path.data: /usr/local/elasticsearch/data</div><div class="line">path.logs: /usr/local/elasticsearch/logs</div><div class="line">bootstrap.memory_lock: true</div><div class="line">bootstrap.system_call_filter: false</div><div class="line">network.host: 172.16.56.194</div><div class="line">network.publish_host: 172.16.56.194</div><div class="line">discovery.zen.ping.unicast.hosts: [&quot;172.16.56.193&quot;,&quot;172.16.56.195&quot;]</div><div class="line">discovery.zen.minimum_master_nodes: 2</div><div class="line"></div><div class="line"></div><div class="line">[root@localhost ~]# cat /usr/local/elasticsearch/config/elasticsearch.yml |grep -v ^#</div><div class="line">cluster.name: es-ws-v6</div><div class="line">node.name: node-3</div><div class="line">node.master: true</div><div class="line">node.data: true</div><div class="line"></div><div class="line">path.data: /usr/local/elasticsearch/data</div><div class="line">path.logs: /usr/local/elasticsearch/logs</div><div class="line">bootstrap.memory_lock: true</div><div class="line">bootstrap.system_call_filter: false</div><div class="line">network.host: 172.16.56.195</div><div class="line">network.publish_host: 172.16.56.195</div><div class="line">discovery.zen.ping.unicast.hosts: [&quot;172.16.56.193&quot;, &quot;172.16.56.194&quot;]</div><div class="line">discovery.zen.minimum_master_nodes: 2</div></pre></td></tr></table></figure>
<p>  if you need to extend,only to keep cluster.name  with es-ws-v6 ,now we add new node  with config/elasticsearch</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# cat /usr/local/elasticsearch/config/elasticsearch.yml |grep -v ^#</div><div class="line">cluster.name: es-ws-v6</div><div class="line">node.name: node-4</div><div class="line">node.master: true</div><div class="line">node.data: true</div><div class="line"></div><div class="line">path.data: /usr/local/elasticsearch/data</div><div class="line">path.logs: /usr/local/elasticsearch/logs</div><div class="line">bootstrap.memory_lock: true</div><div class="line">bootstrap.system_call_filter: false</div><div class="line">network.host: 172.16.56.196</div><div class="line">network.publish_host: 172.16.56.196</div><div class="line">discovery.zen.ping.unicast.hosts: [&quot;172.16.56.195&quot;]</div><div class="line">discovery.zen.minimum_master_nodes: 2</div></pre></td></tr></table></figure>
</li>
<li><p>start es  and check cluster health,service script look <a href="https://stackoverflow.com/questions/37914831/how-to-start-elasticsearch-run-as-service-in-centos-7" target="_blank" rel="external">here</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#start es</div><div class="line">su es</div><div class="line">cd /usr/local/elasticsearch</div><div class="line">bin/elasticsearch -d -p es.pid</div><div class="line"># check health</div><div class="line">curl http://172.16.56.193:9200/_cluster/health</div></pre></td></tr></table></figure>
</li>
<li><p>restart es cluster service</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">#Disable shard allocation.</div><div class="line">curl -XPUT &apos;172.16.56.193:9200/_cluster/settings?pretty&apos; -H &apos;Content-Type: application/json&apos; -d&apos;</div><div class="line">&#123;</div><div class="line">  &quot;persistent&quot;: &#123;</div><div class="line">    &quot;cluster.routing.allocation.enable&quot;: &quot;none&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">&apos;</div><div class="line"></div><div class="line">#Stop indexing and perform a synced flush.</div><div class="line">curl -XPOST &apos;172.16.56.193:9200/_flush/synced?pretty&apos;</div><div class="line"></div><div class="line">#kill all node</div><div class="line">sudo -i service elasticsearch stop</div><div class="line">#If you are running Elasticsearch as a daemon:</div><div class="line">ps aux |grep elasticsearch |awk &apos;&#123;print $2&#125;&apos; |xargs kill</div><div class="line"></div><div class="line">#Start each upgraded node.</div><div class="line">#you can use _cat/health and _cat/nodes to monitor nodes joining the cluster:</div><div class="line">#If you have dedicated master nodes, start them first and wait for them to form a cluster </div><div class="line">#and elect a master before proceeding with your data nodes. You can check progress by looking at the logs.</div><div class="line"></div><div class="line">curl -XGET &apos;172.16.56.193:9200/_cat/nodes?pretty&apos;</div><div class="line">curl -XGET &apos;172.16.56.193:9200/_cat/health?pretty&apos;</div><div class="line"></div><div class="line"></div><div class="line">#Wait for all nodes to join the cluster and report a status of yellow.</div><div class="line"></div><div class="line">#Reenable allocation</div><div class="line">curl -XPUT &apos;172.16.56.193:9200/_cluster/settings?pretty&apos; -H &apos;Content-Type: application/json&apos; -d&apos;</div><div class="line">&#123;</div><div class="line">  &quot;transient&quot;: &#123;</div><div class="line">    &quot;cluster.routing.allocation.enable&quot;: &quot;all&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">&apos;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>ref<br><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/restart-upgrade.html" target="_blank" rel="external">Elasticsearch Reference</a><br><a href="http://wdxtub.com/2016/09/28/elasticsearch-cluster-guide/" target="_blank" rel="external">Elasticsearch 集群指南</a><br><a href="http://www.wklken.me/posts/2016/06/29/deploy-es.html" target="_blank" rel="external">ELASTICSEARCH集群部署文档</a></p>
<hr>
<p>您的鼓励是我写作最大的动力</p>
<p>俗话说，投资效率是最好的投资。 如果您感觉我的文章质量不错，读后收获很大，预计能为您提高 10% 的工作效率，不妨小额捐助我一下，让我有动力继续写出更多好文章。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;ElasticSearch-deploy-doc&quot;&gt;&lt;a href=&quot;#ElasticSearch-deploy-doc&quot; class=&quot;headerlink&quot; title=&quot;ElasticSearch deploy doc&quot;&gt;&lt;/a&gt;&lt;b&gt;ElasticSear
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>glibc升级引起locale警告</title>
    <link href="https://t1ger.github.io/2017/11/06/glibc%E5%8D%87%E7%BA%A7%E5%BC%95%E8%B5%B7locale%E8%AD%A6%E5%91%8A/"/>
    <id>https://t1ger.github.io/2017/11/06/glibc升级引起locale警告/</id>
    <published>2017-11-06T04:04:24.000Z</published>
    <updated>2017-11-06T04:59:27.611Z</updated>
    
    <content type="html"><![CDATA[<p>在升级glibc后,发现每次登录都提示如下警告：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">-bash: warning: setlocale: LC_CTYPE: cannot change locale (en_US.UTF-8): No such file or directory</div><div class="line">-bash: warning: setlocale: LC_COLLATE: cannot change locale (en_US.UTF-8): No such file or directory</div><div class="line">-bash: warning: setlocale: LC_MESSAGES: cannot change locale (en_US.UTF-8): No such file or directory</div><div class="line">-bash: warning: setlocale: LC_NUMERIC: cannot change locale (en_US.UTF-8): No such file or directory</div><div class="line">-bash: warning: setlocale: LC_TIME: cannot change locale (en_US.UTF-8): No such file or directory</div></pre></td></tr></table></figure></p>
<p>让我们先回顾下升级glibc步骤<br>1、使用 strings /lib64/libc.so.6 |grep GLIBC查看目前系统的glibc版本<br>2、wget <a href="http://ftp.gnu.org/gnu/glibc/glibc-2.14.tar.gz" target="_blank" rel="external">http://ftp.gnu.org/gnu/glibc/glibc-2.14.tar.gz</a><br>3、glibc安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# tar xvf glibc-2.14.tar.gz</div><div class="line">[root@localhost ~]# cd glibc-2.14</div><div class="line">[root@localhost glibc-2.14]# mkdir build</div><div class="line">[root@localhost glibc-2.14]# cd ./build</div><div class="line">[root@localhost build]# ../configure --prefix=/usr/local/glibc-2.14</div><div class="line">[root@localhost build]# make</div><div class="line">[root@localhost build]# make install</div></pre></td></tr></table></figure></p>
<p>4、创建glibc2.14的软链<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ln -sf /usr/local/glibc-2.14/lib/libc-2.14.so /lib64/libc.so.6 ###特别说明，千万不要先删除之前的软链，直接加-f参数覆盖就行了，否则无法开机</div></pre></td></tr></table></figure></p>
<p>5、设置语言相关的locale-archive文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# find / -name locale-archive   ###找出glibc2.12的语言相关的 locale-archive 文件</div><div class="line">/usr/lib/locale/locale-archive</div><div class="line">[root@localhost locale]# cp /usr/lib/locale/locale-archive /usr/local/glibc-2.14/lib/locale/   ###复制到编译好的glibc 2.14的lib/locale中，记得先创建locale目录</div><div class="line">[root@localhost locale]# /usr/local/glibc-2.14/bin/localedef -i en_US -f UTF-8 en_US.UTF-8  ##运行生成相应的locale配置文件</div></pre></td></tr></table></figure></p>
<p>在升级之后出现报警的原因是漏掉了步骤5</p>
<p>ref<br><a href="http://blog.csdn.net/qq_34605594/article/details/73610126" target="_blank" rel="external">升级glibc到glibc-2.14解决version `GLIBC_2.14’ not found 问题</a><br><a href="http://www.cnblogs.com/xiaohuo2011/p/7509034.html" target="_blank" rel="external">GLIBC2.12升级GLIBC2.14源码</a></p>
<hr>
<p>您的鼓励是我写作最大的动力</p>
<p>俗话说，投资效率是最好的投资。 如果您感觉我的文章质量不错，读后收获很大，预计能为您提高 10% 的工作效率，不妨小额捐助我一下，让我有动力继续写出更多好文章。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在升级glibc后,发现每次登录都提示如下警告：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>go标准库04 网络(net包)</title>
    <link href="https://t1ger.github.io/2017/09/28/go%E6%A0%87%E5%87%86%E5%BA%9304-%E7%BD%91%E7%BB%9C-net%E5%8C%85/"/>
    <id>https://t1ger.github.io/2017/09/28/go标准库04-网络-net包/</id>
    <published>2017-09-28T09:17:16.000Z</published>
    <updated>2017-09-28T08:26:05.123Z</updated>
    
    <content type="html"><![CDATA[<p>net包提供了可移植的网络I/O接口，包括TCP/IP、UDP、域名解析和Unix域socket。</p>
<p>我们大部分使用者只需要Dial、Listen和Accept函数提供的基本接口；以及相关的Conn和Listener接口。crypto/tls包提供了相同的接口和类似的Dial和Listen函数。</p>
<p>Dial函数和服务端建立连接：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">conn, err := net.Dial(&quot;tcp&quot;, &quot;google.com:80&quot;)</div><div class="line">if err != nil &#123;</div><div class="line">	// handle error</div><div class="line">&#125;</div><div class="line">fmt.Fprintf(conn, &quot;GET / HTTP/1.0\r\n\r\n&quot;)</div><div class="line">status, err := bufio.NewReader(conn).ReadString(&apos;\n&apos;)</div><div class="line">// ...</div></pre></td></tr></table></figure></p>
<p>Listen函数创建的服务端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">ln, err := net.Listen(&quot;tcp&quot;, &quot;:8080&quot;)</div><div class="line">if err != nil &#123;</div><div class="line">	// handle error</div><div class="line">&#125;</div><div class="line">for &#123;</div><div class="line">	conn, err := ln.Accept()</div><div class="line">	if err != nil &#123;</div><div class="line">		// handle error</div><div class="line">		continue</div><div class="line">	&#125;</div><div class="line">	go handleConnection(conn)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果我们要实现一个http web服务,一般通过两种方法实现,一种是我们使用net包的net.Listen来对端口进行监听,另一个是使用net/http包,这里我们看下用net/http如何实现</p>
<ul>
<li><p>http客户端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">import (</div><div class="line">    &quot;fmt&quot;</div><div class="line">    &quot;net/http&quot;</div><div class="line">    &quot;io/ioutil&quot;</div><div class="line">)</div><div class="line"> </div><div class="line">func main() &#123;</div><div class="line">    response,_ := http.Get(&quot;http://www.baidu.com&quot;)</div><div class="line">    defer response.Body.Close()</div><div class="line">    body,_ := ioutil.ReadAll(response.Body)</div><div class="line">    fmt.Println(string(body))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>http服务端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"> </div><div class="line">import (</div><div class="line">    &quot;net/http&quot;</div><div class="line">)</div><div class="line"> </div><div class="line">func SayHello(w http.ResponseWriter, req *http.Request) &#123;</div><div class="line">    w.Write([]byte(&quot;Hello&quot;))</div><div class="line">&#125;</div><div class="line"> </div><div class="line">func main() &#123;</div><div class="line">    http.HandleFunc(&quot;/hello&quot;, SayHello)</div><div class="line">    http.ListenAndServe(&quot;:8001&quot;, nil)</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  进行端口的监听：http.ListenAndServe(“:8001”, nil)<br>注册路径处理函数：http.HandleFunc(“/hello”, SayHello)<br>处理函数：func SayHello(w http.ResponseWriter, req *http.Request)</p>
</li>
</ul>
<hr>
<p>您的鼓励是我写作最大的动力</p>
<p>俗话说，投资效率是最好的投资。 如果您感觉我的文章质量不错，读后收获很大，预计能为您提高 10% 的工作效率，不妨小额捐助我一下，让我有动力继续写出更多好文章。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;net包提供了可移植的网络I/O接口，包括TCP/IP、UDP、域名解析和Unix域socket。&lt;/p&gt;
&lt;p&gt;我们大部分使用者只需要Dial、Listen和Accept函数提供的基本接口；以及相关的Conn和Listener接口。crypto/tls包提供了相同的接口和
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>go标准库03 路径与文件</title>
    <link href="https://t1ger.github.io/2017/09/28/go%E6%A0%87%E5%87%86%E5%BA%9303-%E8%B7%AF%E5%BE%84%E4%B8%8E%E6%96%87%E4%BB%B6/"/>
    <id>https://t1ger.github.io/2017/09/28/go标准库03-路径与文件/</id>
    <published>2017-09-28T04:22:53.000Z</published>
    <updated>2017-09-28T07:45:49.825Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><p>os包<br>提供系统相关函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">import (</div><div class="line"> &quot;fmt&quot;</div><div class="line"> &quot;os&quot;</div><div class="line">)</div><div class="line">func main() &#123;</div><div class="line"> dir, _ := os.Getwd()</div><div class="line"> fmt.Println(&quot;current dir:&quot;, dir)</div><div class="line"> fmt.Println(os.Geteuid())</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  此外,还有os.Getenv(),os.Chdir(),)os.Stat(),os.Chmod(),os.Chtime(),os.Environ(),os.Exit(),os.Expand(),os.ExpandEnv(),os.Hostname()等,详细介绍请查看<a href="https://golang.org/pkg/os/" target="_blank" rel="external">这里</a></p>
</li>
<li><p>io包<br>io包提供了大量的输入输出相关的函数,用来处理io.Reader和io.Writer.(*os.File类型的值能同时满足这两个接口的定义).另外,这个包还能用来创建内存中的同步管道.<br>io/ioutil包提供一些高级的辅助函数.<br>在io包中最重要的是两个接口：Reader和Writer接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">type Reader interface &#123;</div><div class="line">    Read(p []byte) (n int, err error)</div><div class="line">&#125;</div><div class="line"></div><div class="line">type Writer interface &#123;</div><div class="line">    Write(p []byte) (n int, err error)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  Read 将 len(p) 个字节读取到 p 中，当遇到任何错误（包括EOF）会立即返回已读取的字节数，函数结束会返回成功读取的字节数和任何错误。<br>Write 将 len(p) 字节数据从 p 写入底层的数据流，然后返回成功写入的字节数和任何错误。<br>从接口名称很容易猜到，一般地，Go中接口的命名约定：接口名以er结尾。<br>注意，这里并非强行要求，你完全可以不以 er 结尾。标准库中有些接口也不是以 er 结尾的</p>
</li>
<li><p>path包<br>path包用来操作unix风格的路径<br>path/filepath包提供了和path相同的函数,其目标是提供平台无关的路径处理,提供了filepath.Walk()函数来遍历读出一个给定路径下的所有文件和目录信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">        &quot;fmt&quot;</div><div class="line">        &quot;path/filepath&quot;</div><div class="line">)</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line"></div><div class="line">        absName, err := filepath.Abs(&quot;/a/b/c.txt&quot;)</div><div class="line">        if err != nil &#123;</div><div class="line">                fmt.Println(err)</div><div class="line">        &#125;</div><div class="line">        fmt.Println(absName)</div><div class="line"></div><div class="line">        baseName := filepath.Base(&quot;/a/b/c/e.txt&quot;)</div><div class="line">        fmt.Println(baseName)</div><div class="line"></div><div class="line">        p := &quot;../..//././//a/b/c.txt&quot;</div><div class="line">        pc := filepath.Clean(p)</div><div class="line">        fmt.Println(pc)</div><div class="line"></div><div class="line">        d := filepath.Dir(&quot;/a/b/c/d.txt&quot;)</div><div class="line">        fmt.Println(d)</div><div class="line"></div><div class="line">        e, _ := filepath.EvalSymlinks(&quot;/home/tiger/abc&quot;)</div><div class="line">        fmt.Println(e)</div><div class="line"></div><div class="line">        f := filepath.Ext(&quot;/tmp/1.txt&quot;)</div><div class="line">        fmt.Println(f)</div><div class="line"></div><div class="line">        m, _ := filepath.Glob(&quot;/usr/*&quot;)</div><div class="line">        fmt.Println(m)</div><div class="line"></div><div class="line">        fmt.Println(&quot;On Unix:&quot;)</div><div class="line">        fmt.Println(filepath.Join(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;))</div><div class="line">        fmt.Println(filepath.Join(&quot;a&quot;, &quot;b/c&quot;))</div><div class="line">        fmt.Println(filepath.Join(&quot;a/b&quot;, &quot;c&quot;))</div><div class="line">        fmt.Println(filepath.Join(&quot;a/b&quot;, &quot;/c&quot;))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  此外,还有 Split(), Walk()等</p>
</li>
</ul>
<ul>
<li>runtime包<br>runtime包含一些函数和类型,用来访问go语言的运行时系统<br>这里介绍几个跟平台有关的方法：NumCPU ,GOROOT ,GOOS ,GOMAXPROCS ,Gosched<br>func NumCPU() int<br>func GOROOT() string<br>func GOMAXPROCS(n int) int<br>func Gosched()<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">    &quot;fmt&quot;</div><div class="line">    &quot;runtime&quot;</div><div class="line">)</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    fmt.Println(&quot;cpus:&quot;, runtime.NumCPU())</div><div class="line">    fmt.Println(&quot;goroot:&quot;, runtime.GOROOT())</div><div class="line">    fmt.Println(&quot;os/platform:&quot;, runtime.GOOS)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<p>您的鼓励是我写作最大的动力</p>
<p>俗话说，投资效率是最好的投资。 如果您感觉我的文章质量不错，读后收获很大，预计能为您提高 10% 的工作效率，不妨小额捐助我一下，让我有动力继续写出更多好文章。</p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;os包&lt;br&gt;提供系统相关函数&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>go标准库02 时间与日期</title>
    <link href="https://t1ger.github.io/2017/09/28/go%E6%A0%87%E5%87%86%E5%BA%9302-%E6%97%B6%E9%97%B4%E4%B8%8E%E6%97%A5%E6%9C%9F/"/>
    <id>https://t1ger.github.io/2017/09/28/go标准库02-时间与日期/</id>
    <published>2017-09-28T02:56:14.000Z</published>
    <updated>2017-09-28T03:19:12.363Z</updated>
    
    <content type="html"><![CDATA[<p>Go具有良好的时间和日期管理功能。实际上，计算机只会维护一个挂钟时间(wall clock time)，这个时间是从某个固定时间起点到现在的时间间隔。时间起点的选择与计算机相关，但一台计算机的话，这一时间起点是固定的。其它的日期信息都是从这一时间计算得到的。</p>
<h5 id="time包"><a href="#time包" class="headerlink" title="time包"></a><b>time包</b></h5><ul>
<li><p>时间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">    &quot;fmt&quot;</div><div class="line">    &quot;time&quot;</div><div class="line">)</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    //时间戳</div><div class="line">    t := time.Now().Unix()</div><div class="line">    fmt.Print(t)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>time.sleep()<br>可以将程序置于休眠状态，直到某时间间隔之后再唤醒程序，让程序继续运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">    &quot;fmt&quot;</div><div class="line">    &quot;time&quot;</div><div class="line">)</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">        fmt.Println(&quot;start&quot;)</div><div class="line">        time.Sleep(time.Second * 10)  // sleep for 10 seconds</div><div class="line">        fmt.Println(&quot;wake up&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  当我们需要定时地查看程序运行状态时，就可以利用该方法。</p>
</li>
<li><p>time.After(time.Duration)<br>和Sleep差不多，在取出管道内容前不阻塞</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">    &quot;fmt&quot;</div><div class="line">    &quot;time&quot;</div><div class="line">)</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    fmt.Println(&quot;this is one&quot;)</div><div class="line">    tc:=time.After(time.Second)</div><div class="line">    fmt.Println(&quot;this is two&quot;)</div><div class="line">    fmt.Println(&quot;this is three&quot;)</div><div class="line">    &lt;-tc //阻塞中，直到取出tc管道里的数据 </div><div class="line">    fmt.Println(&quot;this is four&quot;)</div><div class="line">&#125;</div><div class="line">//打印this is one后，获得了一个空管道，这个管道1秒后会有数据进来</div><div class="line">//打印this is two</div><div class="line">//打印this is three</div><div class="line">//等待，直到可以取出管道的数据（取出数据的时间与获得tc管道的时间正好差1秒钟）</div><div class="line">//打印this is four</div></pre></td></tr></table></figure>
</li>
<li><p>time.AfterFunc(time.Duration,func())<br>和After差不多，意思是多少时间之后在goroutine line执行函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">    &quot;time&quot;</div><div class="line">    &quot;fmt&quot;</div><div class="line">)</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    f := func() &#123;</div><div class="line">        fmt.Println(&quot;Time out&quot;)</div><div class="line">    &#125;</div><div class="line">    time.AfterFunc(1*time.Second,f)</div><div class="line">    time.Sleep(2 * time.Second) //要保证主线比子线“死的晚”，否则主线死了，子线也等于死了</div><div class="line">&#125;</div><div class="line">//将一个间隔和一个函数给AfterFunc后</div><div class="line">//间隔时间过后，执行传入的函数</div></pre></td></tr></table></figure>
</li>
<li><p>Before &amp; After方法<br>判断一个时间点是否在另一个时间点的前面（后面），返回true或false</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">    &quot;time&quot;</div><div class="line">    &quot;fmt&quot;</div><div class="line">)</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    t1 := time.Now()</div><div class="line">    time.Sleep(time.Second)</div><div class="line">    t2 := time.Now()</div><div class="line">    a := t2.After(t1)</div><div class="line">    fmt.Println(a) //true</div><div class="line">    b := t2.Before(t1)</div><div class="line">    fmt.Println(b) //false</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>sub方法<br>两个时间点相减，获得时间差(Duration)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">    &quot;time&quot;</div><div class="line">    &quot;fmt&quot;</div><div class="line">)</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    t1 := time.Now()</div><div class="line">    time.Sleep(time.Second)</div><div class="line">    t2 :=time.Now()</div><div class="line">    d := t2.Sub(t1) //时间2减去时间1</div><div class="line">    fmt.Println(d)  //打印结果差不多为1.000123几秒，因为Sleep无法做到精确的睡1秒</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Add方法<br>拿一个时间点，add一个时长，获得另一个时间点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">    &quot;time&quot;</div><div class="line">    &quot;fmt&quot;</div><div class="line">)</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    t1 := time.Now()</div><div class="line">    t2 := t1.Add(time.Hour)</div><div class="line">    fmt.Println(t2)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<p>您的鼓励是我写作最大的动力</p>
<p>俗话说，投资效率是最好的投资。 如果您感觉我的文章质量不错，读后收获很大，预计能为您提高 10% 的工作效率，不妨小额捐助我一下，让我有动力继续写出更多好文章。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Go具有良好的时间和日期管理功能。实际上，计算机只会维护一个挂钟时间(wall clock time)，这个时间是从某个固定时间起点到现在的时间间隔。时间起点的选择与计算机相关，但一台计算机的话，这一时间起点是固定的。其它的日期信息都是从这一时间计算得到的。&lt;/p&gt;
&lt;h5
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>go标准库01 正则表达式(regexp包)</title>
    <link href="https://t1ger.github.io/2017/09/07/go%E6%A0%87%E5%87%86%E5%BA%9301-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-regexp%E5%8C%85/"/>
    <id>https://t1ger.github.io/2017/09/07/go标准库01-正则表达式-regexp包/</id>
    <published>2017-09-07T08:03:11.000Z</published>
    <updated>2017-09-07T10:07:22.386Z</updated>
    
    <content type="html"><![CDATA[<p>我将从正则表达式开始讲Go的标准库。正则表达式是文字处理中常用的工具，而且不需要额外的系统知识或经验。我们会把系统相关的包放在后面讲解。<br>正则表达式(regular expression)主要功能是从字符串(string)中通过特定的模式(pattern)，搜索想要找到的内容。</p>
<h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a><b>语法</b></h5><p>regexp包实现了正则表达式搜索。<br>正则表达式采用RE2语法（除了\c、\C），和Perl、Python等语言的正则基本一致<br>在go中使用正则表达式需要标准库中的一个包regexp</p>
<p>func Match(pattern string, b []byte) (matched bool, err error)<br>Match检查b中是否存在匹配pattern的子序列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line">import (</div><div class="line">    &quot;regexp&quot;</div><div class="line">    &quot;fmt&quot;</div><div class="line">)</div><div class="line">func main() &#123;</div><div class="line">    fmt.Println(regexp.Match(&quot;[0-9] &quot;, []byte(&quot;abcd5ef&quot;)))</div><div class="line">&#125;</div><div class="line"></div><div class="line">[tiger@bogon go]$ go run reg.go </div><div class="line">false &lt;nil&gt;</div></pre></td></tr></table></figure>
<p>如果你熟悉Linux或者Perl, 你应该已经熟悉正则表达式。当我们打开Linux shell的时候，可以用正则表达式去查找或着删除我们想要的文件，比如说：<br>$rm log[0-9][0-9].txt<br>这就是要删除类似于log02.txt的文件。log[0-9][0-9].txt所包含的信息是，以log开头，后面跟两个数字字符，之后跟有”.txt”的文件名。如果不符合条件的文件名，比如说:<br>log12.txt<br>log1.txt<br>log99.text<br>都不会被选中。<br>Perl中内建有正则表达式的功能，据说是所有正则表达式系统中最强的，这也是Perl成为系统管理员利器的一个原因。</p>
<h5 id="正则表达式的函数"><a href="#正则表达式的函数" class="headerlink" title="正则表达式的函数"></a><b>正则表达式的函数</b></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">func (re *Regexp) FindString(s string) string   //搜索整个字符串，直到发现符合的子字符串</div><div class="line">func (re *Regexp) MatchString(s string) bool   //MatchString类似Match，但匹配对象是字符串。</div></pre></td></tr></table></figure>
<p>可以从这两个函数中选择一个进行搜索。上面的例子中，我们如果使用regexp.MatchString()的话，则会得到False，因为字符串的起始为‘a’， 不符合’[0-9]’的要求。</p>
<p>我们还可以在搜索之后将搜索到的子字符串进行替换：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">func (re *Regexp) FindAllStringSubmatch(s string, n int) [][]string</div></pre></td></tr></table></figure></p>
<p>Find返回一个保管正则表达式re在b中的所有不重叠的匹配结果及其对应的（可能有的）分组匹配的结果的[][]string切片。如果没有匹配到，会返回nil。</p>
<p>此外，常用的正则表达式函数还有</p>
<p>func (re *Regexp) Split(s string, n int) []string<br>Split将re在s中匹配到的结果作为分隔符将s分割成多个字符串，并返回这些正则匹配结果之间的字符串的切片。</p>
<p>func (re *Regexp) FindAllString(s string, n int) []string<br>Find返回保管正则表达式re在b中的所有不重叠的匹配结果的[]string切片。如果没有匹配到，会返回nil。</p>
<h5 id="写一个正则表达式"><a href="#写一个正则表达式" class="headerlink" title="写一个正则表达式"></a><b>写一个正则表达式</b></h5><p>关键在于将信息写成一个正则表达式。我们先看正则表达式的常用语法</p>
<ul>
<li><p>单个字符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">.          任意的一个字符</div><div class="line">a|b        字符a或字符b</div><div class="line">[afg]      a或者f或者g的一个字符        </div><div class="line">[0-4]      0-4范围内的一个字符</div><div class="line">[a-f]      a-f范围内的一个字符</div><div class="line">[^m]       不是m的一个字符</div><div class="line">\s         一个空格</div><div class="line">\S         一个非空格</div><div class="line">\d         [0-9]</div><div class="line">\D         [^0-9]</div><div class="line">\w         [0-9a-zA-Z]</div><div class="line">\W         [^0-9a-zA-Z]</div></pre></td></tr></table></figure>
</li>
<li><p>重复<br>紧跟在单个字符之后，表示多个这样类似的字符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">*         重复 &gt;=0 次</div><div class="line">+         重复 &gt;=1 次</div><div class="line">?         重复 0或者1 次</div><div class="line">&#123;m&#125;       重复m次。比如说 a&#123;4&#125;相当于aaaa，再比如说[1-3]&#123;2&#125;相当于[1-3][1-3]</div><div class="line">&#123;m, n&#125;    重复m到n次。比如说a&#123;2, 5&#125;表示a重复2到5次。小于m次的重复，或者大于n次的重复都不符合条件。</div><div class="line"></div><div class="line">正则表达          相符的字符串举例</div><div class="line">[0-9]&#123;3,5&#125;       9678</div><div class="line">a?b              b</div><div class="line">a+b              aaaaab</div></pre></td></tr></table></figure>
</li>
<li><p>位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">^         字符串的起始位置</div><div class="line">$         字符串的结尾位置</div><div class="line"></div><div class="line">正则表达          相符的字符串举例        不相符字符串</div><div class="line">^ab.*c$          abeec               cabeec</div></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<p>您的鼓励是我写作最大的动力</p>
<p>俗话说，投资效率是最好的投资。 如果您感觉我的文章质量不错，读后收获很大，预计能为您提高 10% 的工作效率，不妨小额捐助我一下，让我有动力继续写出更多好文章。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我将从正则表达式开始讲Go的标准库。正则表达式是文字处理中常用的工具，而且不需要额外的系统知识或经验。我们会把系统相关的包放在后面讲解。&lt;br&gt;正则表达式(regular expression)主要功能是从字符串(string)中通过特定的模式(pattern)，搜索想要找
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>go标准库--走马观花</title>
    <link href="https://t1ger.github.io/2017/09/07/go%E6%A0%87%E5%87%86%E5%BA%93-%E8%B5%B0%E9%A9%AC%E8%A7%82%E8%8A%B1/"/>
    <id>https://t1ger.github.io/2017/09/07/go标准库-走马观花/</id>
    <published>2017-09-07T04:20:13.000Z</published>
    <updated>2017-09-07T05:45:48.602Z</updated>
    
    <content type="html"><![CDATA[<p>Go有一套很有用的标准库(standard library)。它是Go的一个组成部分。这些标准库是Go为你准备好的利器，可以让编程事半功倍。</p>
<p>我将根据我个人的使用经验中，挑选出标准库三个方面的包(package)介绍：</p>
<ul>
<li>go增强</li>
<li>系统互动</li>
<li>网络</li>
</ul>
<h5 id="go增强"><a href="#go增强" class="headerlink" title="go增强"></a><b>go增强</b></h5><p>go自身的已有的一些功能可以随着标准库的使用而得到增强</p>
<ul>
<li><p>文字处理<br>Go的strings包提供了对字符串进行处理的方法.更进一步，通过标准库中的regexp包,Go可以用正则表达式(regular expression)来处理字符串。<br>正则表达式是一个字符串模板。Go可以从字符中搜查符合该模板的部分，或者对这一部分替换成其它内容。比如你可以搜索一个文本中所有的数字。正则表达式的关键在于根据自己的需要构成模板。<br>此外，Go标准库还为字符串的输出提供更加丰富的格式，比如: strconv,bytes,unicode</p>
</li>
<li><p>数据结构与算法<br>数据结构是数据组织和存储的逻辑形式,为了有效的使用资源,在时间和空间上有效的算法可以帮助我们,Go标准库提供了sort,inedex/suffixary,container<br>sort 包包含基本的排序方法，支持切片数据排序以及用户自定义数据集合排序<br>index/suffixary 包实现了后缀数组相关算法以支持许多常见的字符串操作<br>container 包提供了对heap、list和ring这3种数据结构的底层支持。任何实现了相应接口的数据结构都可以调用该结构的方法</p>
</li>
<li><p>日期和时间<br>日期和时间的管理并不复杂，但容易犯错。经常会遇到日期和时间相关的操作,比如：格式化日期和时间，解析一个日期时间字符串等。Go语言通过标准库 time 包处理日期和时间相关的问题<br>time包提供了用于测量时间、解析和格式化日期，日期/时间以及时间值的函数。time.After()函数可用于在特定纳秒后，向通道 (channel)发送当前时间。time.Tick()和time.NewTicker()函数可用于提供一个通道，它会返回在特定时间间隔后将 ‘tick’发送到该通道上。time.Time结构具有一些方法，可提供当前时间，将data/time格式化为一个字符串以及解析data /time</p>
</li>
<li><p>数学运算<br>math/big包提供了无限大(实际受限于内存)整型数(big.Int)以及有理数(big.Rat)。math包提供了所有标准数学函数(基于float64)以及一些标准常量。math/cmplx包提供一些用于复数计算的标准函数(基于complex128)<br>此外,math/rand包提供许多有用的伪随机数生成函数，包括返回一个随机整型数的rand.Int()以及rand.Intn(n)，后者返回[0,n]范围内的一个随机整数。crypto/rand包中有一个函数，可用于产生加密的强伪随机数字</p>
</li>
<li><p>存储<br>在数据交换方面，有很多成熟的协议可以使用，常用的有：JSON、XML等,Go 语言提供了解析它们的标准库；同时，为了方便 Go 程序直接数据交换，Go 专门提供了 gob 这种交换协议<br>此外，标准库中还支持基本的数据库功能(database/sql包),csv格式的文件也有相应的处理包</p>
</li>
<li><p>数据压缩与归档<br>Go 标准库实现了一些最流行的压缩标准。zlib 和 gzip 提供了 GNU zip 库，bzip2 用于读写 bzip2 格式<br>标准库提供了 LZW 压缩算法（串表压缩算法）的实现，该算法常用的文件格式：GIF 和 PDF。<br>标准库还提供一些包管理归档(archive)格式,archive/tar 读写 UNIX 磁带归档格式,archive/zip 根据 zip 格式来处理归档</p>
</li>
</ul>
<h5 id="系统互动"><a href="#系统互动" class="headerlink" title="系统互动"></a><b>系统互动</b></h5><ul>
<li><p>操作系统<br>Go 的标准库提供了很多工具，可以处理文件系统中的文件、构造和解析文件名等,path包提供的函数用于操作Unix样式路径<br>runtime包包含了许多函数和类型用于访问Go的运行时系统</p>
</li>
<li><p>进程与线程<br>在Go中提供os 包及其子包 os/exec 提供了创建进程的方法,同时,我们知道在 Linux 中，通过系统调用 clone() 来实现线程的,在 Go 中，通过 clone() 系统调用来创建线程</p>
</li>
</ul>
<h5 id="网络"><a href="#网络" class="headerlink" title="网络"></a><b>网络</b></h5><ul>
<li>网络包<br>Go标准库中有许多包用于支持网络以及相关方面的编程。net包提供的函数和类型可用于使用Unix域以及网络socket通信、TCP/IP和UDP编程<br>net/http包充分利用了net包，并提供了解析HTTP请求和应答的功能，并提供了一个基本的HTTP客户端。net/http包也包含一个易于扩展的HTTP server。net/url包提供了URL解析和查询转义<br>标准库中还包含其他一些其他高层次的网络包。一个是net/rpc(远程过程调用)包，它允许一个服务端提供导出可被客户端调用的方法的对象。另外一个是net/smtp(简单邮件传输协议)包，可用于发送email</li>
</ul>
<p>以上的介绍比较粗糙，只希望能为大家提供一个了解标准库的入口。欢迎大家一起分享标准库的使用经验。</p>
<hr>
<p>您的鼓励是我写作最大的动力</p>
<p>俗话说，投资效率是最好的投资。 如果您感觉我的文章质量不错，读后收获很大，预计能为您提高 10% 的工作效率，不妨小额捐助我一下，让我有动力继续写出更多好文章。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Go有一套很有用的标准库(standard library)。它是Go的一个组成部分。这些标准库是Go为你准备好的利器，可以让编程事半功倍。&lt;/p&gt;
&lt;p&gt;我将根据我个人的使用经验中，挑选出标准库三个方面的包(package)介绍：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;go增强&lt;/l
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Go进阶07 defer,panic,recover</title>
    <link href="https://t1ger.github.io/2017/09/04/Go%E8%BF%9B%E9%98%B607-defer-panic-recover/"/>
    <id>https://t1ger.github.io/2017/09/04/Go进阶07-defer-panic-recover/</id>
    <published>2017-09-04T09:39:56.000Z</published>
    <updated>2017-09-04T10:12:22.322Z</updated>
    
    <content type="html"><![CDATA[<h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a><b>概念</b></h5><ul>
<li>defer<br>在函数返回前执行一些操作,表达式通常用来处理一些清理和释放资源的操作</li>
<li>panic<br>表示非常严重的不可恢复的错误,panic一般会导致程序挂掉(除非recover),重要的一点是,即使函数执行的时候panic了,函数不往下走了，运行时并不是立刻向上传递panic,而是到defer那,等defer的东西都跑完了,panic再向上传递</li>
<li>recover<br>Go语言提供了recover内置函数,一旦panic,逻辑就会走到defer那,那我们就在defer那等着,调用recover函数将会捕获到当前的panic(如果有的话),被捕获到的panic就不会向上传递了<br>要注意的是，recover之后，逻辑并不会恢复到panic那个点去，函数还是会在defer之后返回</li>
</ul>
<h5 id="用法"><a href="#用法" class="headerlink" title="用法"></a><b>用法</b></h5><p>首先我们来看下defer,在官方的文档中看到defer的执行顺序是逆序的，也就是先进后出的顺序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">for i :=0; i&lt; 5; i++ &#123;</div><div class="line">    defer fmt.Printf(&quot;%d &quot;, i)</div><div class="line">&#125;</div><div class="line"></div><div class="line">[tiger@bogon go]$ go run defer.go   </div><div class="line">4 3 2 1 0</div></pre></td></tr></table></figure></p>
<p>如何从panic中恢复呢? recover()函数用于获取/拦截panic,仅当在一个defer函数中被完成时.下面来看三个例子<br>错误的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line">import fmt</div><div class="line">func main() &#123; </div><div class="line">    recover()         //don&apos;t do anything</div><div class="line">    panic(&quot;not good&quot;)</div><div class="line">    recover()        //will not be executed</div><div class="line">    fmt.Println(&quot;ok&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>正确的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line">import fmt</div><div class="line">func main() &#123;</div><div class="line">    defer func() &#123;</div><div class="line">	    fmt.Println(&quot;recovered:&quot;,recover())</div><div class="line">	&#125;()</div><div class="line">	</div><div class="line">    panic(&quot;not good&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>失败的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line">import fmt</div><div class="line">func doRecover()&#123;</div><div class="line">    fmt.Println(&quot;recovered =&gt;&quot;, recover()) //prints: recovered =&gt; &lt;nil&gt;</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    defer func() &#123;</div><div class="line">        doRecover() //panic is not recovered</div><div class="line">	&#125;()</div><div class="line">    panic(&quot;not good&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a><b>总结</b></h5><p>defer可以多次，这样形成一个defer栈，后defer的语句在函数返回时将先被调用<br>panic一般会导致程序挂掉<br>recover()的调用仅当它在defer函数中被直接调用时才有效<br>recover之后，逻辑并不会恢复到panic那个点去，函数还是会在defer之后返回</p>
<hr>
<p>您的鼓励是我写作最大的动力</p>
<p>俗话说，投资效率是最好的投资。 如果您感觉我的文章质量不错，读后收获很大，预计能为您提高 10% 的工作效率，不妨小额捐助我一下，让我有动力继续写出更多好文章。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;&lt;b&gt;概念&lt;/b&gt;&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;defer&lt;br&gt;在函数返回前执行一些操作,表达式通常用来处理一些清理和释放资源的操作&lt;/li&gt;
&lt;li&gt;pani
    
    </summary>
    
    
  </entry>
  
</feed>
