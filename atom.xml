<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>t1ger的茶馆</title>
  <subtitle>头顶有光终是幻，足下生云未是仙</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://t1ger.github.io/"/>
  <updated>2017-09-07T09:18:30.870Z</updated>
  <id>https://t1ger.github.io/</id>
  
  <author>
    <name>t1ger</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>go标准库01 正则表达式(regexp包)</title>
    <link href="https://t1ger.github.io/2017/09/07/go%E6%A0%87%E5%87%86%E5%BA%9301-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-regexp%E5%8C%85/"/>
    <id>https://t1ger.github.io/2017/09/07/go标准库01-正则表达式-regexp包/</id>
    <published>2017-09-07T08:03:11.000Z</published>
    <updated>2017-09-07T09:18:30.870Z</updated>
    
    <content type="html"><![CDATA[<p>我将从正则表达式开始讲Go的标准库。正则表达式是文字处理中常用的工具，而且不需要额外的系统知识或经验。我们会把系统相关的包放在后面讲解。<br>正则表达式(regular expression)主要功能是从字符串(string)中通过特定的模式(pattern)，搜索想要找到的内容。</p>
<h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a><b>语法</b></h5><p>regexp包实现了正则表达式搜索。<br>正则表达式采用RE2语法（除了\c、\C），和Perl、Python等语言的正则基本一致<br>在go中使用正则表达式需要标准库中的一个包regexp</p>
<p>func Match(pattern string, b []byte) (matched bool, err error)<br>Match检查b中是否存在匹配pattern的子序列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line">import (</div><div class="line">    &quot;regexp&quot;</div><div class="line">    &quot;fmt&quot;</div><div class="line">)</div><div class="line">func main() &#123;</div><div class="line">    fmt.Println(regexp.Match(&quot;[0-9] &quot;, []byte(&quot;abcd5ef&quot;)))</div><div class="line">&#125;</div><div class="line"></div><div class="line">[tiger@bogon go]$ go run reg.go </div><div class="line">false &lt;nil&gt;</div></pre></td></tr></table></figure>
<p>如果你熟悉Linux或者Perl, 你应该已经熟悉正则表达式。当我们打开Linux shell的时候，可以用正则表达式去查找或着删除我们想要的文件，比如说：<br>$rm log[0-9][0-9].txt<br>这就是要删除类似于log02.txt的文件。log[0-9][0-9].txt所包含的信息是，以log开头，后面跟两个数字字符，之后跟有”.txt”的文件名。如果不符合条件的文件名，比如说:<br>log12.txt<br>log1.txt<br>log99.text<br>都不会被选中。<br>Perl中内建有正则表达式的功能，据说是所有正则表达式系统中最强的，这也是Perl成为系统管理员利器的一个原因。</p>
<h5 id="正则表达式的函数"><a href="#正则表达式的函数" class="headerlink" title="正则表达式的函数"></a><b>正则表达式的函数</b></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">func (re *Regexp) FindString(s string) string   //搜索整个字符串，直到发现符合的子字符串</div><div class="line">func (re *Regexp) MatchString(s string) bool   //MatchString类似Match，但匹配对象是字符串。</div></pre></td></tr></table></figure>
<p>可以从这两个函数中选择一个进行搜索。上面的例子中，我们如果使用regexp.MatchString()的话，则会得到False，因为字符串的起始为‘a’， 不符合’[0-9]’的要求。</p>
<p>我们还可以在搜索之后将搜索到的子字符串进行替换：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">func (re *Regexp) FindAllStringSubmatch(s string, n int) [][]string</div></pre></td></tr></table></figure></p>
<p>Find返回一个保管正则表达式re在b中的所有不重叠的匹配结果及其对应的（可能有的）分组匹配的结果的[][]string切片。如果没有匹配到，会返回nil。</p>
<p>此外，常用的正则表达式函数还有</p>
<p>func (re *Regexp) Split(s string, n int) []string<br>Split将re在s中匹配到的结果作为分隔符将s分割成多个字符串，并返回这些正则匹配结果之间的字符串的切片。</p>
<p>func (re *Regexp) FindAllString(s string, n int) []string<br>Find返回保管正则表达式re在b中的所有不重叠的匹配结果的[]string切片。如果没有匹配到，会返回nil。</p>
<h5 id="写一个正则表达式"><a href="#写一个正则表达式" class="headerlink" title="写一个正则表达式"></a><b>写一个正则表达式</b></h5><p>关键在于将信息写成一个正则表达式。我们先看正则表达式的常用语法</p>
<ul>
<li><p>单个字符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">.          任意的一个字符</div><div class="line">a|b        字符a或字符b</div><div class="line">[afg]      a或者f或者g的一个字符        </div><div class="line">[0-4]      0-4范围内的一个字符</div><div class="line">[a-f]      a-f范围内的一个字符</div><div class="line">[^m]       不是m的一个字符</div><div class="line">\s         一个空格</div><div class="line">\S         一个非空格</div><div class="line">\d         [0-9]</div><div class="line">\D         [^0-9]</div><div class="line">\w         [0-9a-zA-Z]</div><div class="line">\W         [^0-9a-zA-Z]</div></pre></td></tr></table></figure>
</li>
<li><p>重复<br>紧跟在单个字符之后，表示多个这样类似的字符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">*         重复 &gt;=0 次</div><div class="line">+         重复 &gt;=1 次</div><div class="line">?         重复 0或者1 次</div><div class="line">&#123;m&#125;       重复m次。比如说 a&#123;4&#125;相当于aaaa，再比如说[1-3]&#123;2&#125;相当于[1-3][1-3]</div><div class="line">&#123;m, n&#125;    重复m到n次。比如说a&#123;2, 5&#125;表示a重复2到5次。小于m次的重复，或者大于n次的重复都不符合条件。</div><div class="line"></div><div class="line">正则表达          相符的字符串举例</div><div class="line">[0-9]&#123;3,5&#125;       9678</div><div class="line">a?b              b</div><div class="line">a+b              aaaaab</div></pre></td></tr></table></figure>
</li>
<li><p>位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">^         字符串的起始位置</div><div class="line">$         字符串的结尾位置</div><div class="line"></div><div class="line">正则表达          相符的字符串举例        不相符字符串</div><div class="line">^ab.*c$          abeec               cabeec</div></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<p>您的鼓励是我写作最大的动力</p>
<p>俗话说，投资效率是最好的投资。 如果您感觉我的文章质量不错，读后收获很大，预计能为您提高 10% 的工作效率，不妨小额捐助我一下，让我有动力继续写出更多好文章。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我将从正则表达式开始讲Go的标准库。正则表达式是文字处理中常用的工具，而且不需要额外的系统知识或经验。我们会把系统相关的包放在后面讲解。&lt;br&gt;正则表达式(regular expression)主要功能是从字符串(string)中通过特定的模式(pattern)，搜索想要找
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>go标准库--走马观花</title>
    <link href="https://t1ger.github.io/2017/09/07/go%E6%A0%87%E5%87%86%E5%BA%93-%E8%B5%B0%E9%A9%AC%E8%A7%82%E8%8A%B1/"/>
    <id>https://t1ger.github.io/2017/09/07/go标准库-走马观花/</id>
    <published>2017-09-07T04:20:13.000Z</published>
    <updated>2017-09-07T05:45:48.602Z</updated>
    
    <content type="html"><![CDATA[<p>Go有一套很有用的标准库(standard library)。它是Go的一个组成部分。这些标准库是Go为你准备好的利器，可以让编程事半功倍。</p>
<p>我将根据我个人的使用经验中，挑选出标准库三个方面的包(package)介绍：</p>
<ul>
<li>go增强</li>
<li>系统互动</li>
<li>网络</li>
</ul>
<h5 id="go增强"><a href="#go增强" class="headerlink" title="go增强"></a><b>go增强</b></h5><p>go自身的已有的一些功能可以随着标准库的使用而得到增强</p>
<ul>
<li><p>文字处理<br>Go的strings包提供了对字符串进行处理的方法.更进一步，通过标准库中的regexp包,Go可以用正则表达式(regular expression)来处理字符串。<br>正则表达式是一个字符串模板。Go可以从字符中搜查符合该模板的部分，或者对这一部分替换成其它内容。比如你可以搜索一个文本中所有的数字。正则表达式的关键在于根据自己的需要构成模板。<br>此外，Go标准库还为字符串的输出提供更加丰富的格式，比如: strconv,bytes,unicode</p>
</li>
<li><p>数据结构与算法<br>数据结构是数据组织和存储的逻辑形式,为了有效的使用资源,在时间和空间上有效的算法可以帮助我们,Go标准库提供了sort,inedex/suffixary,container<br>sort 包包含基本的排序方法，支持切片数据排序以及用户自定义数据集合排序<br>index/suffixary 包实现了后缀数组相关算法以支持许多常见的字符串操作<br>container 包提供了对heap、list和ring这3种数据结构的底层支持。任何实现了相应接口的数据结构都可以调用该结构的方法</p>
</li>
<li><p>日期和时间<br>日期和时间的管理并不复杂，但容易犯错。经常会遇到日期和时间相关的操作,比如：格式化日期和时间，解析一个日期时间字符串等。Go语言通过标准库 time 包处理日期和时间相关的问题<br>time包提供了用于测量时间、解析和格式化日期，日期/时间以及时间值的函数。time.After()函数可用于在特定纳秒后，向通道 (channel)发送当前时间。time.Tick()和time.NewTicker()函数可用于提供一个通道，它会返回在特定时间间隔后将 ‘tick’发送到该通道上。time.Time结构具有一些方法，可提供当前时间，将data/time格式化为一个字符串以及解析data /time</p>
</li>
<li><p>数学运算<br>math/big包提供了无限大(实际受限于内存)整型数(big.Int)以及有理数(big.Rat)。math包提供了所有标准数学函数(基于float64)以及一些标准常量。math/cmplx包提供一些用于复数计算的标准函数(基于complex128)<br>此外,math/rand包提供许多有用的伪随机数生成函数，包括返回一个随机整型数的rand.Int()以及rand.Intn(n)，后者返回[0,n]范围内的一个随机整数。crypto/rand包中有一个函数，可用于产生加密的强伪随机数字</p>
</li>
<li><p>存储<br>在数据交换方面，有很多成熟的协议可以使用，常用的有：JSON、XML等,Go 语言提供了解析它们的标准库；同时，为了方便 Go 程序直接数据交换，Go 专门提供了 gob 这种交换协议<br>此外，标准库中还支持基本的数据库功能(database/sql包),csv格式的文件也有相应的处理包</p>
</li>
<li><p>数据压缩与归档<br>Go 标准库实现了一些最流行的压缩标准。zlib 和 gzip 提供了 GNU zip 库，bzip2 用于读写 bzip2 格式<br>标准库提供了 LZW 压缩算法（串表压缩算法）的实现，该算法常用的文件格式：GIF 和 PDF。<br>标准库还提供一些包管理归档(archive)格式,archive/tar 读写 UNIX 磁带归档格式,archive/zip 根据 zip 格式来处理归档</p>
</li>
</ul>
<h5 id="系统互动"><a href="#系统互动" class="headerlink" title="系统互动"></a><b>系统互动</b></h5><ul>
<li><p>操作系统<br>Go 的标准库提供了很多工具，可以处理文件系统中的文件、构造和解析文件名等,path包提供的函数用于操作Unix样式路径<br>runtime包包含了许多函数和类型用于访问Go的运行时系统</p>
</li>
<li><p>进程与线程<br>在Go中提供os 包及其子包 os/exec 提供了创建进程的方法,同时,我们知道在 Linux 中，通过系统调用 clone() 来实现线程的,在 Go 中，通过 clone() 系统调用来创建线程</p>
</li>
</ul>
<h5 id="网络"><a href="#网络" class="headerlink" title="网络"></a><b>网络</b></h5><ul>
<li>网络包<br>Go标准库中有许多包用于支持网络以及相关方面的编程。net包提供的函数和类型可用于使用Unix域以及网络socket通信、TCP/IP和UDP编程<br>net/http包充分利用了net包，并提供了解析HTTP请求和应答的功能，并提供了一个基本的HTTP客户端。net/http包也包含一个易于扩展的HTTP server。net/url包提供了URL解析和查询转义<br>标准库中还包含其他一些其他高层次的网络包。一个是net/rpc(远程过程调用)包，它允许一个服务端提供导出可被客户端调用的方法的对象。另外一个是net/smtp(简单邮件传输协议)包，可用于发送email</li>
</ul>
<p>以上的介绍比较粗糙，只希望能为大家提供一个了解标准库的入口。欢迎大家一起分享标准库的使用经验。</p>
<hr>
<p>您的鼓励是我写作最大的动力</p>
<p>俗话说，投资效率是最好的投资。 如果您感觉我的文章质量不错，读后收获很大，预计能为您提高 10% 的工作效率，不妨小额捐助我一下，让我有动力继续写出更多好文章。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Go有一套很有用的标准库(standard library)。它是Go的一个组成部分。这些标准库是Go为你准备好的利器，可以让编程事半功倍。&lt;/p&gt;
&lt;p&gt;我将根据我个人的使用经验中，挑选出标准库三个方面的包(package)介绍：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;go增强&lt;/l
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Go进阶07 defer,panic,recover</title>
    <link href="https://t1ger.github.io/2017/09/04/Go%E8%BF%9B%E9%98%B607-defer-panic-recover/"/>
    <id>https://t1ger.github.io/2017/09/04/Go进阶07-defer-panic-recover/</id>
    <published>2017-09-04T09:39:56.000Z</published>
    <updated>2017-09-04T10:12:22.322Z</updated>
    
    <content type="html"><![CDATA[<h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a><b>概念</b></h5><ul>
<li>defer<br>在函数返回前执行一些操作,表达式通常用来处理一些清理和释放资源的操作</li>
<li>panic<br>表示非常严重的不可恢复的错误,panic一般会导致程序挂掉(除非recover),重要的一点是,即使函数执行的时候panic了,函数不往下走了，运行时并不是立刻向上传递panic,而是到defer那,等defer的东西都跑完了,panic再向上传递</li>
<li>recover<br>Go语言提供了recover内置函数,一旦panic,逻辑就会走到defer那,那我们就在defer那等着,调用recover函数将会捕获到当前的panic(如果有的话),被捕获到的panic就不会向上传递了<br>要注意的是，recover之后，逻辑并不会恢复到panic那个点去，函数还是会在defer之后返回</li>
</ul>
<h5 id="用法"><a href="#用法" class="headerlink" title="用法"></a><b>用法</b></h5><p>首先我们来看下defer,在官方的文档中看到defer的执行顺序是逆序的，也就是先进后出的顺序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">for i :=0; i&lt; 5; i++ &#123;</div><div class="line">    defer fmt.Printf(&quot;%d &quot;, i)</div><div class="line">&#125;</div><div class="line"></div><div class="line">[tiger@bogon go]$ go run defer.go   </div><div class="line">4 3 2 1 0</div></pre></td></tr></table></figure></p>
<p>如何从panic中恢复呢? recover()函数用于获取/拦截panic,仅当在一个defer函数中被完成时.下面来看三个例子<br>错误的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line">import fmt</div><div class="line">func main() &#123; </div><div class="line">    recover()         //don&apos;t do anything</div><div class="line">    panic(&quot;not good&quot;)</div><div class="line">    recover()        //will not be executed</div><div class="line">    fmt.Println(&quot;ok&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>正确的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line">import fmt</div><div class="line">func main() &#123;</div><div class="line">    defer func() &#123;</div><div class="line">	    fmt.Println(&quot;recovered:&quot;,recover())</div><div class="line">	&#125;()</div><div class="line">	</div><div class="line">    panic(&quot;not good&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>失败的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line">import fmt</div><div class="line">func doRecover()&#123;</div><div class="line">    fmt.Println(&quot;recovered =&gt;&quot;, recover()) //prints: recovered =&gt; &lt;nil&gt;</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    defer func() &#123;</div><div class="line">        doRecover() //panic is not recovered</div><div class="line">	&#125;()</div><div class="line">    panic(&quot;not good&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a><b>总结</b></h5><p>defer可以多次，这样形成一个defer栈，后defer的语句在函数返回时将先被调用<br>panic一般会导致程序挂掉<br>recover()的调用仅当它在defer函数中被直接调用时才有效<br>recover之后，逻辑并不会恢复到panic那个点去，函数还是会在defer之后返回</p>
<hr>
<p>您的鼓励是我写作最大的动力</p>
<p>俗话说，投资效率是最好的投资。 如果您感觉我的文章质量不错，读后收获很大，预计能为您提高 10% 的工作效率，不妨小额捐助我一下，让我有动力继续写出更多好文章。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;&lt;b&gt;概念&lt;/b&gt;&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;defer&lt;br&gt;在函数返回前执行一些操作,表达式通常用来处理一些清理和释放资源的操作&lt;/li&gt;
&lt;li&gt;pani
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Go进阶06 iota</title>
    <link href="https://t1ger.github.io/2017/09/04/Go%E8%BF%9B%E9%98%B606-iota/"/>
    <id>https://t1ger.github.io/2017/09/04/Go进阶06-iota/</id>
    <published>2017-09-04T04:45:34.000Z</published>
    <updated>2017-09-04T08:22:30.391Z</updated>
    
    <content type="html"><![CDATA[<h5 id="iota简介"><a href="#iota简介" class="headerlink" title="iota简介"></a><b>iota简介</b></h5><p>iota 是golang的常量计数器,只能在常量的表达式中使用.<br>iota在const关键字出现时将被重置为0,const中每新增一行将使iota计数一次<br>iota可以简化定义,经常用在枚举的时候</p>
<h5 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a><b>常见用法</b></h5><ul>
<li>iota只能在常量表达式中使用</li>
<li><p>每次const出现时,iota会初始化为0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const a = iota  // a = 0</div><div class="line">const (</div><div class="line">    b = iota    // b = 0 </div><div class="line">    c 		// c = 1</div><div class="line">)</div></pre></td></tr></table></figure>
</li>
<li><p>自定义类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const (</div><div class="line">    red = iota</div><div class="line">    blue</div><div class="line">    green</div><div class="line">)</div></pre></td></tr></table></figure>
</li>
<li><p>可跳过的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">const (</div><div class="line">    red = iota  // 0</div><div class="line">    blue        // 1 </div><div class="line">    green       // 2</div><div class="line">    - </div><div class="line">    -</div><div class="line">    yellow      // 5</div><div class="line">    black       // 6</div><div class="line">)</div></pre></td></tr></table></figure>
</li>
<li><p>定义数量级</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">type ByteSize float64</div><div class="line">const(</div><div class="line">    _     = iota                 // ignore first value by assigning to blank identifier</div><div class="line">    KB ByteSize = 1 &lt;&lt; (10*iota) // 1&lt;&lt;(10*1)</div><div class="line">    MB                           // 1&lt;&lt;(10*2)</div><div class="line">    GB                           // 1&lt;&lt;(10*3)</div><div class="line">    TB                           // 1&lt;&lt;(10*4)</div><div class="line">    PB                           // 1&lt;&lt;(10*5)</div><div class="line">    EB                           // 1&lt;&lt;(10*6)</div><div class="line">    ZB                           // 1&lt;&lt;(10*7)</div><div class="line">    YB                           // 1&lt;&lt;(10*8)</div><div class="line">)</div></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<p>您的鼓励是我写作最大的动力</p>
<p>俗话说，投资效率是最好的投资。 如果您感觉我的文章质量不错，读后收获很大，预计能为您提高 10% 的工作效率，不妨小额捐助我一下，让我有动力继续写出更多好文章。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;iota简介&quot;&gt;&lt;a href=&quot;#iota简介&quot; class=&quot;headerlink&quot; title=&quot;iota简介&quot;&gt;&lt;/a&gt;&lt;b&gt;iota简介&lt;/b&gt;&lt;/h5&gt;&lt;p&gt;iota 是golang的常量计数器,只能在常量的表达式中使用.&lt;br&gt;iota在const关
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Go进阶05 fallthrough</title>
    <link href="https://t1ger.github.io/2017/09/04/Go%E8%BF%9B%E9%98%B605-fallthrough/"/>
    <id>https://t1ger.github.io/2017/09/04/Go进阶05-fallthrough/</id>
    <published>2017-09-04T03:50:20.000Z</published>
    <updated>2017-09-04T10:25:28.264Z</updated>
    
    <content type="html"><![CDATA[<h5 id="fallthrough用法"><a href="#fallthrough用法" class="headerlink" title="fallthrough用法"></a><b>fallthrough用法</b></h5><p>Go里边的switch默认每个case匹配成功后不会自动向下执行其他case,直接跳出switch,fallthrough强制执行后边的case代码,fallthrough不对下一条的case表达式进行判断<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    switch a:=10; &#123;</div><div class="line">    case a &gt;= 9:</div><div class="line">        fmt.Println(&quot;&gt;=9&quot;)</div><div class="line">        fallthrough</div><div class="line">    case a &gt;= 10: </div><div class="line">        fmt.Println(&quot;&gt;=10&quot;)</div><div class="line">        fallthrough</div><div class="line">    case a &gt;= 15:</div><div class="line">        fmt.Println(&quot;&gt;=15&quot;)</div><div class="line">        fallthrough</div><div class="line">    case a &gt;= 20:</div><div class="line">        fmt.Println(&quot;&gt;=20&quot;)</div><div class="line">        fallthrough</div><div class="line">    default:</div><div class="line">        fmt.Println(&quot;default&quot;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">[tiger@bogon go]$ go run fallthrough.go </div><div class="line">&gt;=9</div><div class="line">&gt;=10</div><div class="line">&gt;=15</div><div class="line">&gt;=20</div><div class="line">default</div></pre></td></tr></table></figure></p>
<p>fallthrough可不可以放到最后一个呢,我们在default里添加之后,我们运行一下看看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[tiger@bogon go]$ go run fallthrough.go </div><div class="line"># command-line-arguments</div><div class="line">./fallthrough.go:21: cannot fallthrough final case in switch</div></pre></td></tr></table></figure>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a><b>总结</b></h5><p>fallthrough:Go里面switch默认相当于每个case最后带有break，匹配成功后不会自动向下执行其他case，而是跳出整个switch, 但是可以使用fallthrough强制执行后面的case代码<br>fallthrough不能用在switch最后一个分支</p>
<hr>
<p>您的鼓励是我写作最大的动力</p>
<p>俗话说，投资效率是最好的投资。 如果您感觉我的文章质量不错，读后收获很大，预计能为您提高 10% 的工作效率，不妨小额捐助我一下，让我有动力继续写出更多好文章。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;fallthrough用法&quot;&gt;&lt;a href=&quot;#fallthrough用法&quot; class=&quot;headerlink&quot; title=&quot;fallthrough用法&quot;&gt;&lt;/a&gt;&lt;b&gt;fallthrough用法&lt;/b&gt;&lt;/h5&gt;&lt;p&gt;Go里边的switch默认每个case
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Go进阶04 函数闭包和不定参数</title>
    <link href="https://t1ger.github.io/2017/08/24/Go%E8%BF%9B%E9%98%B604-%E5%87%BD%E6%95%B0%E9%97%AD%E5%8C%85%E5%92%8C%E4%B8%8D%E5%AE%9A%E5%8F%82%E6%95%B0/"/>
    <id>https://t1ger.github.io/2017/08/24/Go进阶04-函数闭包和不定参数/</id>
    <published>2017-08-24T08:06:54.000Z</published>
    <updated>2017-08-24T09:41:50.895Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><p>匿名函数<br>在了解闭包之前,我们先说下什么是匿名函数,匿名函数由一个不带函数名的函数声明和函数体组成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">func (a, b int, z float64) bool &#123;</div><div class="line">    return a*b &lt; int(z)</div><div class="line">&#125;</div><div class="line"></div><div class="line">//匿名函数可以赋值给一个变量</div><div class="line">f := func(x, y int) int &#123;</div><div class="line">    return x + y</div><div class="line">&#125;</div><div class="line"></div><div class="line">func(ch chan int) &#123;</div><div class="line">    ch &lt;-ACK</div><div class="line">&#125;(reply_chan) //直接跟参数表示函数调用</div></pre></td></tr></table></figure>
</li>
<li><p>闭包<br>Go的匿名函数就是一个闭包,闭包是可以包含自由变量的代码块,这些变量不在这个代码块内或者任何全局上下文中定义,而是在定义代码块的环境中定义.<br>要执行的代码块(由于自由变量包含在代码块中,这些自由变量以及他们引用的对象没有被释放)为自由变量提供绑定的计算环境(作用域)</p>
<p>  Go语言中的闭包同样会引用到函数外的变量.闭包的实现确保只要闭包还被使用,那么被闭包引用的变量会一直存在</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    var j int = 5</div><div class="line">	</div><div class="line">	a := func()(func()) &#123;</div><div class="line">        var i int = 10</div><div class="line">        return func() &#123;</div><div class="line">            fmt.Printf(&quot;i, j: %d, %d\n&quot;, i, j)</div><div class="line">        &#125;</div><div class="line">    &#125;()</div><div class="line">    a()</div><div class="line">    j *= 2</div><div class="line">    a()</div><div class="line">&#125;</div><div class="line"></div><div class="line">[tiger@bogon tiger]$ go run closure.go </div><div class="line">i, j: 10, 5</div><div class="line">i, j: 10, 10</div></pre></td></tr></table></figure>
<p>  变量a指向的闭包函数引用了局部变量i和j, i的值被隔离,在闭包外不能被修改,改变j的值以后,再次调用a, 发现结构是修改过的值<br>在变量a指向的闭包函数中,只有内部的匿名函数才能访问变量i,而无法通过其他途径访问到,因此保证了i的安全性 </p>
</li>
<li><p>不定参数<br>不定参数是指函数接受传入的参数为不定数量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">func myfunc(args ...int)&#123;</div><div class="line">    for _, arg := range args&#123;</div><div class="line">        fmt.Println(arg)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//原样传递</div><div class="line">myfunc(args...)</div><div class="line">//传递片段</div><div class="line">myfunc(args[1:]...)</div><div class="line"></div><div class="line">myfunc(2, 4, 6)</div><div class="line">myfunc(1, 3, 4, 6)</div></pre></td></tr></table></figure>
<p>  如果传递的参数不是int,而是任意类型,可以指定类型为interface(),我们来看下Go语言标准库中fmt.Printf()的函数原型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func Printf(format string, args ...interface&#123;&#125;) &#123;</div><div class="line">// ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  下面代码是展示如何处理传入interface{}类型的参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">func MyPrintf(args ...interface&#123;&#125;) &#123;</div><div class="line">    for _, arg := range args &#123;</div><div class="line">	    switch arg.(type) &#123;</div><div class="line">            case int:</div><div class="line">                fmt.Println(arg, &quot;is an int value.&quot;)</div><div class="line">            case string:</div><div class="line">                fmt.Println(arg, &quot;is a string value.&quot;)</div><div class="line">            case int64:</div><div class="line">                fmt.Println(arg, &quot;is an int64 value.&quot;)</div><div class="line">            default:</div><div class="line">                fmt.Println(arg, &quot;is an unknow type.&quot;)</div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    var v1 int = 1</div><div class="line">    var v2 int64 = 234</div><div class="line">    var v3 string = &quot;hello&quot;</div><div class="line">    var v4 float32 = 1.456</div><div class="line">    MyPrintf(v1, v2, v3, v4)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>总结<br>匿名函数<br>闭包,Go的匿名函数就是一个闭包<br>不定参数</p>
</li>
</ul>
<hr>
<p>您的鼓励是我写作最大的动力</p>
<p>俗话说，投资效率是最好的投资。 如果您感觉我的文章质量不错，读后收获很大，预计能为您提高 10% 的工作效率，不妨小额捐助我一下，让我有动力继续写出更多好文章。</p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;匿名函数&lt;br&gt;在了解闭包之前,我们先说下什么是匿名函数,匿名函数由一个不带函数名的函数声明和函数体组成&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Go进阶03 Range</title>
    <link href="https://t1ger.github.io/2017/08/24/Go%E8%BF%9B%E9%98%B603-Range/"/>
    <id>https://t1ger.github.io/2017/08/24/Go进阶03-Range/</id>
    <published>2017-08-24T05:03:48.000Z</published>
    <updated>2017-08-24T06:57:16.618Z</updated>
    
    <content type="html"><![CDATA[<p>range 关键字用于for循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素。在数组和切片中它返回元素的索引值，在集合中返回 key-value 对的 key 值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot; </div><div class="line"></div><div class="line">func main() &#123;</div><div class="line"></div><div class="line">// range for slice</div><div class="line">    nums := []int&#123;2, 3, 4&#125;</div><div class="line">        sum := 0</div><div class="line">        for _, num := range nums &#123;</div><div class="line">            sum += num</div><div class="line">        &#125;</div><div class="line">    fmt.Println(&quot;sum: &quot;, sum)</div><div class="line">        for i, num := range nums &#123;</div><div class="line">             if num == 3 &#123;</div><div class="line">                 fmt.Println(&quot;index: &quot;, i)</div><div class="line">             &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">// range for map</div><div class="line">   mp := map[string]string&#123;&quot;1&quot;: &quot;apple&quot;, &quot;2&quot;:&quot;banan&quot;&#125;</div><div class="line">   for k, v := range mp &#123;</div><div class="line">       fmt.Printf(&quot;%s -- &gt; %s\n&quot;, k, v)</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">// range for channel</div><div class="line">    queue := make(chan string, 2)</div><div class="line">    queue &lt;- &quot;one&quot;</div><div class="line">    queue &lt;- &quot;two&quot;</div><div class="line">    close(queue)</div><div class="line">        </div><div class="line">    for v := range queue &#123;</div><div class="line">        fmt.Println(v)</div><div class="line">    &#125;</div><div class="line">   </div><div class="line">   </div><div class="line">//  range for enum Unicode string</div><div class="line">    for i, c := range &quot;go&quot; &#123;</div><div class="line">        fmt.Println(i, c)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[tiger@bogon tiger]$ go run range.go </div><div class="line">sum:  9</div><div class="line">index:  1</div><div class="line">1 -- &gt; apple</div><div class="line">2 -- &gt; banan</div><div class="line">one</div><div class="line">two</div><div class="line">0 103</div><div class="line">1 111</div></pre></td></tr></table></figure></p>
<p>总结<br>range 关键字用于for循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素.</p>
<hr>
<p>您的鼓励是我写作最大的动力</p>
<p>俗话说，投资效率是最好的投资。 如果您感觉我的文章质量不错，读后收获很大，预计能为您提高 10% 的工作效率，不妨小额捐助我一下，让我有动力继续写出更多好文章。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;range 关键字用于for循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素。在数组和切片中它返回元素的索引值，在集合中返回 key-value 对的 key 值&lt;/p&gt;
&lt;figure class=&quot;highlight pla
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Go进阶02 channel</title>
    <link href="https://t1ger.github.io/2017/08/24/Go%E8%BF%9B%E9%98%B602-channel/"/>
    <id>https://t1ger.github.io/2017/08/24/Go进阶02-channel/</id>
    <published>2017-08-24T03:21:33.000Z</published>
    <updated>2017-08-24T04:01:18.400Z</updated>
    
    <content type="html"><![CDATA[<p>在谈channel之前,我们先说下并发通信,在实践中,有两种最常见的并发通信模型:共享数据和消息,被共享的数据可能有多种形式,比如内存数据块、磁盘文件、网络数据等,一般内存共享最为常见.</p>
<p>Go语言选择消息机制作为通信方式.消息机制认为每个并发单元是自包含的、独立的个体，并且都有自己的变量，但在不同并发单元间这些变量不共享。每个并发单元的输入和输出只有一种，那就是消息。</p>
<p>Go语言提供的消息通信机制就被称为channel,channel是进程内的通信方式,golang channel 分为有缓冲与无缓冲两种类型,它们最大的区别是阻塞问题.不带缓冲的channel兼具通信和同步两种特性</p>
<ul>
<li><p>channel定义和操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">//一般channel声明</div><div class="line">var chanName chan ElementType</div><div class="line">var ch chan int</div><div class="line">var m map[string] chan bool</div><div class="line"></div><div class="line">//定义一个channel</div><div class="line">c := make(chan int)</div><div class="line"></div><div class="line">//定义一个带缓冲的channel</div><div class="line">c := make(chan int, 1024)</div><div class="line"></div><div class="line">//向一个channel发送一个值</div><div class="line">c &lt;- x</div><div class="line"></div><div class="line">//从channel中接收一个值</div><div class="line">&lt;- c</div><div class="line"></div><div class="line">//从channel c接收一个值并存储到x中</div><div class="line">x = &lt;-c </div><div class="line"></div><div class="line">//从channel接收一个值,如果channel关闭或者没数据,ok将为false</div><div class="line">x, ok = &lt;- c</div></pre></td></tr></table></figure>
</li>
<li><p>生产者消费者问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">    &quot;fmt&quot;</div><div class="line">    &quot;time&quot;</div><div class="line">)</div><div class="line"></div><div class="line">func producer(c chan int, max int) &#123;</div><div class="line">    for i :=0; i&lt; max;i++ &#123;</div><div class="line">        c &lt;- i</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">func consumer(c chan int) &#123;</div><div class="line">    ok := true</div><div class="line">	for ok &#123;</div><div class="line">	    if value, ok := &lt;-c; ok &#123;</div><div class="line">                fmt.Println(value)</div><div class="line">            &#125;</div><div class="line">       &#125;</div><div class="line">&#125; </div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    c := make(chan int)</div><div class="line">    defer close(c)    </div><div class="line">    go producer(c, 10)</div><div class="line">    go consumer(c)</div><div class="line">    time.Sleep(time.Millisecond * 10)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  执行结构将依次打印0-9</p>
</li>
<li><p>定时器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">    &quot;fmt&quot;</div><div class="line">    &quot;time&quot;</div><div class="line">)</div><div class="line"></div><div class="line">var mych = make(chan bool)</div><div class="line"></div><div class="line">func task() &#123;</div><div class="line">    fmt.Println(&quot;my timer task..&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func timer() &#123;</div><div class="line">    timeout := time.NewTicker(time.Millisecond * 1000)</div><div class="line">	select &#123;</div><div class="line">	case &lt;- mych:</div><div class="line">	    go task()</div><div class="line">	case &lt;-timeout.C:</div><div class="line">	    fmt.Println(&quot;Time out&quot;)</div><div class="line">	&#125;</div><div class="line">	fmt.Println(&quot;Hello go&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    timer()</div><div class="line">    time.Sleep(time.Millisecond * 10)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  这里没有向mychannel中写数据的，在等10秒之后会打印出hello go，程序并没有因此阻塞在这里</p>
</li>
<li><p>goroutine通信</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line">import (</div><div class="line">    &quot;fmt&quot;</div><div class="line">    &quot;time&quot;</div><div class="line">)</div><div class="line"></div><div class="line">var mych1 = make(chan int)</div><div class="line"></div><div class="line">func routine1() &#123;</div><div class="line">    for i:=0; i&lt; 10; i++ &#123;</div><div class="line">        mych1 &lt;- i</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">func routine2() &#123;</div><div class="line">    for &#123;</div><div class="line">        i := &lt;-mych1</div><div class="line">        fmt.Println(&quot;routine2: &quot;, i)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">func routine3() &#123;</div><div class="line">    for &#123;</div><div class="line">        i := &lt;-mych1</div><div class="line">        fmt.Println(&quot;routine3: &quot;, i)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    go routine1()</div><div class="line">    go routine2()</div><div class="line">    go routine3()</div><div class="line">    time.Sleep(time.Millisecond * 100)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  这里实现了一个goroutine写，两个goroutine读的过程，可以看到按顺序写进去的数据，被哪个goroutine读到是完全随机的，在golang中我们要实现进程间通信，channel是唯一途径，也是推荐的途径，它的底层是通过共享内存实现的</p>
</li>
<li><p>总结<br>channel定义和操作<br>生产者和消费者<br>goroutine通信,在使用channel的时候,至少有一个goroutine来负责读,否则你的程序就会阻塞在你写channel的地方</p>
</li>
</ul>
<hr>
<p>您的鼓励是我写作最大的动力</p>
<p>俗话说，投资效率是最好的投资。 如果您感觉我的文章质量不错，读后收获很大，预计能为您提高 10% 的工作效率，不妨小额捐助我一下，让我有动力继续写出更多好文章。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在谈channel之前,我们先说下并发通信,在实践中,有两种最常见的并发通信模型:共享数据和消息,被共享的数据可能有多种形式,比如内存数据块、磁盘文件、网络数据等,一般内存共享最为常见.&lt;/p&gt;
&lt;p&gt;Go语言选择消息机制作为通信方式.消息机制认为每个并发单元是自包含的、独
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Go进阶01 map</title>
    <link href="https://t1ger.github.io/2017/08/23/Go%E8%BF%9B%E9%98%B601-map/"/>
    <id>https://t1ger.github.io/2017/08/23/Go进阶01-map/</id>
    <published>2017-08-23T09:29:41.000Z</published>
    <updated>2017-08-23T10:34:03.046Z</updated>
    
    <content type="html"><![CDATA[<p>Map 是一种无序的键值对的集合</p>
<ul>
<li><p>定义map<br>可以使用内建函数 make 也可以使用 map 关键字来定义 Map:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 声明变量，默认 map 是 nil </div><div class="line">var map_variable map[key_data_type]value_data_type</div><div class="line"></div><div class="line">// 使用 make 函数 </div><div class="line">map_variable := make(map[key_data_type]value_data_type)</div></pre></td></tr></table></figure>
<p>  如果不初始化 map，那么就会创建一个 nil map。nil map 不能用来存放键值对</p>
</li>
<li><p>实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line"></div><div class="line">//new 进行创建</div><div class="line">    mapA := new(map[int]string)</div><div class="line">    *mapA = map[int]string&#123;&#125;</div><div class="line">    (*mapA)[112] = &quot;112&quot;</div><div class="line">    (*mapA)[110] = &quot;110&quot;</div><div class="line">	</div><div class="line">    for v := range *mapA &#123;</div><div class="line">        fmt.Println(v)</div><div class="line">	&#125;</div><div class="line">//直接创建</div><div class="line">    var map1 map[int]string = map[int]string&#123;&#125;</div><div class="line">    map2 := map[int]string&#123;</div><div class="line">        11:&quot;11&quot;</div><div class="line">        12:&quot;12&quot;</div><div class="line">	&#125;</div><div class="line">    fmt.Println(map2)</div><div class="line">    map1[1] = &quot;222&quot;</div><div class="line">    map1[2] = &quot;333&quot;</div><div class="line">    fmt.Println(map1)</div><div class="line">	</div><div class="line">//make 创建</div><div class="line">    map3 := make(map[int]string, 100)</div><div class="line">    map3[22] = &quot;22&quot;</div><div class="line">    fmt.Println(map3)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>map查找和删除<br>go提供内置函数delete(),参数为 map 和其对应的 key</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    var student map[string]string</div><div class="line">    student = make(map[string]string)</div><div class="line">    student[&quot;liming&quot;] = &quot;小明&quot;</div><div class="line">    student[&quot;hanmeimei&quot;] = &quot;小梅&quot;</div><div class="line">    </div><div class="line">    delete(student, &quot;liming&quot;)</div><div class="line">    liming, ok := student[&quot;liming&quot;]</div><div class="line">    if ok &#123;</div><div class="line">        fmt.Println(liming)</div><div class="line">    &#125; else &#123;</div><div class="line">        fmt.Println(&quot;no exist person&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>总结<br>map<br>delete()</p>
</li>
</ul>
<hr>
<p>您的鼓励是我写作最大的动力</p>
<p>俗话说，投资效率是最好的投资。 如果您感觉我的文章质量不错，读后收获很大，预计能为您提高 10% 的工作效率，不妨小额捐助我一下，让我有动力继续写出更多好文章。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Map 是一种无序的键值对的集合&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;定义map&lt;br&gt;可以使用内建函数 make 也可以使用 map 关键字来定义 Map:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;g
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Go基础08 面向对象的基本概念</title>
    <link href="https://t1ger.github.io/2017/08/23/Go%E5%9F%BA%E7%A1%8008-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>https://t1ger.github.io/2017/08/23/Go基础08-面向对象的基本概念/</id>
    <published>2017-08-23T07:11:22.000Z</published>
    <updated>2017-08-23T07:50:02.741Z</updated>
    
    <content type="html"><![CDATA[<p>Go里没有class关键字,通过使用struct和interface实现面向对象的思想.<br>在传统的面向对象语言中,class是基本单位,是数据成员和当前定义的所有操作,并对外提供公共方法让使用者操作对象.而且必须一开始就定义好了那些操作,不能开放式扩展.</p>
<ul>
<li><p>结构体<br>如果要某个符号对其它包访问,需要将该符合定义为以大写字母开头</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">type Human struct &#123;</div><div class="line">    name string</div><div class="line">    age  int</div><div class="line">    Height float64</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  一个Golang对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//定义一个Human类包含name和age</div><div class="line">type Human struct &#123;</div><div class="line">    name string</div><div class="line">    age  int</div><div class="line">&#125;</div><div class="line"></div><div class="line">//定义一个Men接口</div><div class="line">type Men interface &#123;</div><div class="line">    Say()</div><div class="line">&#125;</div><div class="line"></div><div class="line">//带接收参数的函数称为method</div><div class="line">func (h Human) Say() &#123;</div><div class="line">    fmt.Println(&quot;hello %s&quot;, h.name)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>组合<br>Golang里没有继承,是通过匿名组合来实现,没有传统的继承关系链,同时还能重用父类的方法和成员<br>来看下面的例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">type Base struct &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">func (b Base)show() &#123;</div><div class="line">    println(&quot;hello ws&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">type Child struct &#123;</div><div class="line">    Base</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    child := Child&#123;&#125;</div><div class="line">    child.Show()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>接口<br>Go语言中的接口是一系列操作定义的集合,不允许进行实现，而且也不能定义变量或者常量,这种非侵入式的设计，是为了解耦。接口和类本是不同的东西：类是把数据和代码包装在一起，是为了对内实现,接口则像是一种契约，是为了对外展示,Go语言中如果某个对象实现了这个接口的所有方法,那么就可以说这个对象实现了这个接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">type Interface interface &#123;</div><div class="line">    Len() int</div><div class="line">    Less(i, j int) bool</div><div class="line">    Swap(i, j int)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  空interface(interface{})不包含任何的method，正因为如此，所有的类型都实现了空interface。空interface对于描述起不到任何的作用(因为它不包含任何的method），但是空interface在我们需要存储任意类型的数值的时候相当有用，因为它可以存储任意类型的数值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var a interface&#123;&#125; //define a null interface</div><div class="line">var i int = 5</div><div class="line">s := &quot;Hello world&quot; </div><div class="line">a = int     // a 可以存储任意类型的数值</div><div class="line">a = s</div></pre></td></tr></table></figure>
<p>  一个函数把interface{}作为参数，那么他可以接受任意类型的值作为参数，如果一个函数返回interface{},那么也就可以返回任意类型的值</p>
</li>
<li><p>总结<br>struct是变量的集合<br>interface是方法的集合<br>struct与interface都支持匿名字段, 换言之, 支持组合实现继承<br>golang的struct与C++的class一样, 只能声明变量, 不能初始化</p>
</li>
</ul>
<hr>
<p>您的鼓励是我写作最大的动力</p>
<p>俗话说，投资效率是最好的投资。 如果您感觉我的文章质量不错，读后收获很大，预计能为您提高 10% 的工作效率，不妨小额捐助我一下，让我有动力继续写出更多好文章。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Go里没有class关键字,通过使用struct和interface实现面向对象的思想.&lt;br&gt;在传统的面向对象语言中,class是基本单位,是数据成员和当前定义的所有操作,并对外提供公共方法让使用者操作对象.而且必须一开始就定义好了那些操作,不能开放式扩展.&lt;/p&gt;
&lt;u
    
    </summary>
    
    
  </entry>
  
</feed>
