<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>t1ger的茶馆</title>
  <subtitle>头顶有光终是幻，足下生云未是仙</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://t1ger.github.io/"/>
  <updated>2017-11-21T09:33:58.393Z</updated>
  <id>https://t1ger.github.io/</id>
  
  <author>
    <name>t1ger</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Deploy Elasticsearch</title>
    <link href="https://t1ger.github.io/2017/11/20/Deploy-Elasticsearch/"/>
    <id>https://t1ger.github.io/2017/11/20/Deploy-Elasticsearch/</id>
    <published>2017-11-20T08:31:50.000Z</published>
    <updated>2017-11-21T09:33:58.393Z</updated>
    
    <content type="html"><![CDATA[<h5 id="ElasticSearch-deploy-doc"><a href="#ElasticSearch-deploy-doc" class="headerlink" title="ElasticSearch deploy doc"></a><b>ElasticSearch deploy doc</b></h5><ul>
<li><p>env</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# cat /etc/issue</div><div class="line">CentOS release 6.8 (Final)</div><div class="line">Kernel \r on an \m</div><div class="line"></div><div class="line">[root@localhost ~]# java -version</div><div class="line">java version &quot;1.8.0_112&quot;</div><div class="line">Java(TM) SE Runtime Environment (build 1.8.0_112-b15)</div><div class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.112-b15, mixed mode)</div></pre></td></tr></table></figure>
</li>
<li><p>download es, create es user </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">curl -L -O  https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.0.0.tar.gz</div><div class="line"></div><div class="line">tar -xzf elasticsearch-6.0.0.tar.gz</div><div class="line">sudo useradd es</div><div class="line">mv elasticsearch-6.0.0 /usr/local/elasticsearch</div><div class="line">chown es.es /usr/local/elasticsearch -R</div><div class="line"></div><div class="line">#add es.conf to  /etc/security/limits.d/es.conf</div><div class="line">[root@localhost ~]# cat  /etc/security/limits.d/es.conf</div><div class="line">es soft memlock unlimited</div><div class="line">es hard memlock unlimited</div><div class="line">es soft nofile 204800</div><div class="line">es hard nofile 204800</div><div class="line">es soft nproc  4096</div><div class="line"></div><div class="line">#add option to /etc/sysctl.conf</div><div class="line">vm.max_map_count=655360</div><div class="line">sysctl -p</div></pre></td></tr></table></figure>
</li>
<li><p>conf</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# cat /usr/local/elasticsearch/config/elasticsearch.yml |grep -v ^#</div><div class="line">cluster.name: es-ws-v6</div><div class="line">node.name: node-1</div><div class="line">node.master: true</div><div class="line">node.data: true</div><div class="line">path.data: /usr/local/elasticsearch/data</div><div class="line">path.logs: /usr/local/elasticsearch/logs</div><div class="line">bootstrap.memory_lock: true</div><div class="line">bootstrap.system_call_filter: false</div><div class="line">network.host: 172.16.56.193</div><div class="line">network.publish_host: 172.16.56.193</div><div class="line">discovery.zen.ping.unicast.hosts: [&quot;172.16.56.194&quot;,&quot;172.16.56.195&quot;]</div><div class="line">discovery.zen.minimum_master_nodes: 2</div><div class="line"></div><div class="line"></div><div class="line">[root@localhost ~]# cat /usr/local/elasticsearch/config/elasticsearch.yml |grep -v ^#</div><div class="line">cluster.name: es-ws-v6</div><div class="line">node.name: node-2</div><div class="line">node.master: true</div><div class="line">node.data: true</div><div class="line">path.data: /usr/local/elasticsearch/data</div><div class="line">path.logs: /usr/local/elasticsearch/logs</div><div class="line">bootstrap.memory_lock: true</div><div class="line">bootstrap.system_call_filter: false</div><div class="line">network.host: 172.16.56.194</div><div class="line">network.publish_host: 172.16.56.194</div><div class="line">discovery.zen.ping.unicast.hosts: [&quot;172.16.56.193&quot;,&quot;172.16.56.195&quot;]</div><div class="line">discovery.zen.minimum_master_nodes: 2</div><div class="line"></div><div class="line"></div><div class="line">[root@localhost ~]# cat /usr/local/elasticsearch/config/elasticsearch.yml |grep -v ^#</div><div class="line">cluster.name: es-ws-v6</div><div class="line">node.name: node-3</div><div class="line">node.master: true</div><div class="line">node.data: true</div><div class="line"></div><div class="line">path.data: /usr/local/elasticsearch/data</div><div class="line">path.logs: /usr/local/elasticsearch/logs</div><div class="line">bootstrap.memory_lock: true</div><div class="line">bootstrap.system_call_filter: false</div><div class="line">network.host: 172.16.56.195</div><div class="line">network.publish_host: 172.16.56.195</div><div class="line">discovery.zen.ping.unicast.hosts: [&quot;172.16.56.193&quot;, &quot;172.16.56.194&quot;]</div><div class="line">discovery.zen.minimum_master_nodes: 2</div></pre></td></tr></table></figure>
<p>  if you need to extend,only to keep cluster.name  with es-ws-v6 ,now we add new node  with config/elasticsearch</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# cat /usr/local/elasticsearch/config/elasticsearch.yml |grep -v ^#</div><div class="line">cluster.name: es-ws-v6</div><div class="line">node.name: node-4</div><div class="line">node.master: true</div><div class="line">node.data: true</div><div class="line"></div><div class="line">path.data: /usr/local/elasticsearch/data</div><div class="line">path.logs: /usr/local/elasticsearch/logs</div><div class="line">bootstrap.memory_lock: true</div><div class="line">bootstrap.system_call_filter: false</div><div class="line">network.host: 172.16.56.196</div><div class="line">network.publish_host: 172.16.56.196</div><div class="line">discovery.zen.ping.unicast.hosts: [&quot;172.16.56.195&quot;]</div><div class="line">discovery.zen.minimum_master_nodes: 2</div></pre></td></tr></table></figure>
</li>
<li><p>start es  and check cluster health,service script look <a href="https://stackoverflow.com/questions/37914831/how-to-start-elasticsearch-run-as-service-in-centos-7" target="_blank" rel="external">here</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#start es</div><div class="line">su es</div><div class="line">cd /usr/local/elasticsearch</div><div class="line">bin/elasticsearch -d -p es.pid</div><div class="line"># check health</div><div class="line">curl http://172.16.56.193:9200/_cluster/health</div></pre></td></tr></table></figure>
</li>
<li><p>restart es cluster service</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">#Disable shard allocation.</div><div class="line">curl -XPUT &apos;172.16.56.193:9200/_cluster/settings?pretty&apos; -H &apos;Content-Type: application/json&apos; -d&apos;</div><div class="line">&#123;</div><div class="line">  &quot;persistent&quot;: &#123;</div><div class="line">    &quot;cluster.routing.allocation.enable&quot;: &quot;none&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">&apos;</div><div class="line"></div><div class="line">#Stop indexing and perform a synced flush.</div><div class="line">curl -XPOST &apos;172.16.56.193:9200/_flush/synced?pretty&apos;</div><div class="line"></div><div class="line">#kill all node</div><div class="line">sudo -i service elasticsearch stop</div><div class="line">#If you are running Elasticsearch as a daemon:</div><div class="line">ps aux |grep elasticsearch |awk &apos;&#123;print $2&#125;&apos; |xargs kill</div><div class="line"></div><div class="line">#Start each upgraded node.</div><div class="line">#you can use _cat/health and _cat/nodes to monitor nodes joining the cluster:</div><div class="line">#If you have dedicated master nodes, start them first and wait for them to form a cluster </div><div class="line">#and elect a master before proceeding with your data nodes. You can check progress by looking at the logs.</div><div class="line"></div><div class="line">curl -XGET &apos;172.16.56.193:9200/_cat/nodes?pretty&apos;</div><div class="line">curl -XGET &apos;172.16.56.193:9200/_cat/health?pretty&apos;</div><div class="line"></div><div class="line"></div><div class="line">#Wait for all nodes to join the cluster and report a status of yellow.</div><div class="line"></div><div class="line">#Reenable allocation</div><div class="line">curl -XPUT &apos;172.16.56.193:9200/_cluster/settings?pretty&apos; -H &apos;Content-Type: application/json&apos; -d&apos;</div><div class="line">&#123;</div><div class="line">  &quot;transient&quot;: &#123;</div><div class="line">    &quot;cluster.routing.allocation.enable&quot;: &quot;all&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">&apos;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>ref<br><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/restart-upgrade.html" target="_blank" rel="external">Elasticsearch Reference</a><br><a href="http://wdxtub.com/2016/09/28/elasticsearch-cluster-guide/" target="_blank" rel="external">Elasticsearch 集群指南</a><br><a href="http://www.wklken.me/posts/2016/06/29/deploy-es.html" target="_blank" rel="external">ELASTICSEARCH集群部署文档</a></p>
<hr>
<p>您的鼓励是我写作最大的动力</p>
<p>俗话说，投资效率是最好的投资。 如果您感觉我的文章质量不错，读后收获很大，预计能为您提高 10% 的工作效率，不妨小额捐助我一下，让我有动力继续写出更多好文章。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;ElasticSearch-deploy-doc&quot;&gt;&lt;a href=&quot;#ElasticSearch-deploy-doc&quot; class=&quot;headerlink&quot; title=&quot;ElasticSearch deploy doc&quot;&gt;&lt;/a&gt;&lt;b&gt;ElasticSear
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>glibc升级引起locale警告</title>
    <link href="https://t1ger.github.io/2017/11/06/glibc%E5%8D%87%E7%BA%A7%E5%BC%95%E8%B5%B7locale%E8%AD%A6%E5%91%8A/"/>
    <id>https://t1ger.github.io/2017/11/06/glibc升级引起locale警告/</id>
    <published>2017-11-06T04:04:24.000Z</published>
    <updated>2017-11-06T04:59:27.611Z</updated>
    
    <content type="html"><![CDATA[<p>在升级glibc后,发现每次登录都提示如下警告：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">-bash: warning: setlocale: LC_CTYPE: cannot change locale (en_US.UTF-8): No such file or directory</div><div class="line">-bash: warning: setlocale: LC_COLLATE: cannot change locale (en_US.UTF-8): No such file or directory</div><div class="line">-bash: warning: setlocale: LC_MESSAGES: cannot change locale (en_US.UTF-8): No such file or directory</div><div class="line">-bash: warning: setlocale: LC_NUMERIC: cannot change locale (en_US.UTF-8): No such file or directory</div><div class="line">-bash: warning: setlocale: LC_TIME: cannot change locale (en_US.UTF-8): No such file or directory</div></pre></td></tr></table></figure></p>
<p>让我们先回顾下升级glibc步骤<br>1、使用 strings /lib64/libc.so.6 |grep GLIBC查看目前系统的glibc版本<br>2、wget <a href="http://ftp.gnu.org/gnu/glibc/glibc-2.14.tar.gz" target="_blank" rel="external">http://ftp.gnu.org/gnu/glibc/glibc-2.14.tar.gz</a><br>3、glibc安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# tar xvf glibc-2.14.tar.gz</div><div class="line">[root@localhost ~]# cd glibc-2.14</div><div class="line">[root@localhost glibc-2.14]# mkdir build</div><div class="line">[root@localhost glibc-2.14]# cd ./build</div><div class="line">[root@localhost build]# ../configure --prefix=/usr/local/glibc-2.14</div><div class="line">[root@localhost build]# make</div><div class="line">[root@localhost build]# make install</div></pre></td></tr></table></figure></p>
<p>4、创建glibc2.14的软链<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ln -sf /usr/local/glibc-2.14/lib/libc-2.14.so /lib64/libc.so.6 ###特别说明，千万不要先删除之前的软链，直接加-f参数覆盖就行了，否则无法开机</div></pre></td></tr></table></figure></p>
<p>5、设置语言相关的locale-archive文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# find / -name locale-archive   ###找出glibc2.12的语言相关的 locale-archive 文件</div><div class="line">/usr/lib/locale/locale-archive</div><div class="line">[root@localhost locale]# cp /usr/lib/locale/locale-archive /usr/local/glibc-2.14/lib/locale/   ###复制到编译好的glibc 2.14的lib/locale中，记得先创建locale目录</div><div class="line">[root@localhost locale]# /usr/local/glibc-2.14/bin/localedef -i en_US -f UTF-8 en_US.UTF-8  ##运行生成相应的locale配置文件</div></pre></td></tr></table></figure></p>
<p>在升级之后出现报警的原因是漏掉了步骤5</p>
<p>ref<br><a href="http://blog.csdn.net/qq_34605594/article/details/73610126" target="_blank" rel="external">升级glibc到glibc-2.14解决version `GLIBC_2.14’ not found 问题</a><br><a href="http://www.cnblogs.com/xiaohuo2011/p/7509034.html" target="_blank" rel="external">GLIBC2.12升级GLIBC2.14源码</a></p>
<hr>
<p>您的鼓励是我写作最大的动力</p>
<p>俗话说，投资效率是最好的投资。 如果您感觉我的文章质量不错，读后收获很大，预计能为您提高 10% 的工作效率，不妨小额捐助我一下，让我有动力继续写出更多好文章。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在升级glibc后,发现每次登录都提示如下警告：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>go标准库04 网络(net包)</title>
    <link href="https://t1ger.github.io/2017/09/28/go%E6%A0%87%E5%87%86%E5%BA%9304-%E7%BD%91%E7%BB%9C-net%E5%8C%85/"/>
    <id>https://t1ger.github.io/2017/09/28/go标准库04-网络-net包/</id>
    <published>2017-09-28T09:17:16.000Z</published>
    <updated>2017-09-28T08:26:05.123Z</updated>
    
    <content type="html"><![CDATA[<p>net包提供了可移植的网络I/O接口，包括TCP/IP、UDP、域名解析和Unix域socket。</p>
<p>我们大部分使用者只需要Dial、Listen和Accept函数提供的基本接口；以及相关的Conn和Listener接口。crypto/tls包提供了相同的接口和类似的Dial和Listen函数。</p>
<p>Dial函数和服务端建立连接：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">conn, err := net.Dial(&quot;tcp&quot;, &quot;google.com:80&quot;)</div><div class="line">if err != nil &#123;</div><div class="line">	// handle error</div><div class="line">&#125;</div><div class="line">fmt.Fprintf(conn, &quot;GET / HTTP/1.0\r\n\r\n&quot;)</div><div class="line">status, err := bufio.NewReader(conn).ReadString(&apos;\n&apos;)</div><div class="line">// ...</div></pre></td></tr></table></figure></p>
<p>Listen函数创建的服务端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">ln, err := net.Listen(&quot;tcp&quot;, &quot;:8080&quot;)</div><div class="line">if err != nil &#123;</div><div class="line">	// handle error</div><div class="line">&#125;</div><div class="line">for &#123;</div><div class="line">	conn, err := ln.Accept()</div><div class="line">	if err != nil &#123;</div><div class="line">		// handle error</div><div class="line">		continue</div><div class="line">	&#125;</div><div class="line">	go handleConnection(conn)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果我们要实现一个http web服务,一般通过两种方法实现,一种是我们使用net包的net.Listen来对端口进行监听,另一个是使用net/http包,这里我们看下用net/http如何实现</p>
<ul>
<li><p>http客户端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">import (</div><div class="line">    &quot;fmt&quot;</div><div class="line">    &quot;net/http&quot;</div><div class="line">    &quot;io/ioutil&quot;</div><div class="line">)</div><div class="line"> </div><div class="line">func main() &#123;</div><div class="line">    response,_ := http.Get(&quot;http://www.baidu.com&quot;)</div><div class="line">    defer response.Body.Close()</div><div class="line">    body,_ := ioutil.ReadAll(response.Body)</div><div class="line">    fmt.Println(string(body))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>http服务端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"> </div><div class="line">import (</div><div class="line">    &quot;net/http&quot;</div><div class="line">)</div><div class="line"> </div><div class="line">func SayHello(w http.ResponseWriter, req *http.Request) &#123;</div><div class="line">    w.Write([]byte(&quot;Hello&quot;))</div><div class="line">&#125;</div><div class="line"> </div><div class="line">func main() &#123;</div><div class="line">    http.HandleFunc(&quot;/hello&quot;, SayHello)</div><div class="line">    http.ListenAndServe(&quot;:8001&quot;, nil)</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  进行端口的监听：http.ListenAndServe(“:8001”, nil)<br>注册路径处理函数：http.HandleFunc(“/hello”, SayHello)<br>处理函数：func SayHello(w http.ResponseWriter, req *http.Request)</p>
</li>
</ul>
<hr>
<p>您的鼓励是我写作最大的动力</p>
<p>俗话说，投资效率是最好的投资。 如果您感觉我的文章质量不错，读后收获很大，预计能为您提高 10% 的工作效率，不妨小额捐助我一下，让我有动力继续写出更多好文章。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;net包提供了可移植的网络I/O接口，包括TCP/IP、UDP、域名解析和Unix域socket。&lt;/p&gt;
&lt;p&gt;我们大部分使用者只需要Dial、Listen和Accept函数提供的基本接口；以及相关的Conn和Listener接口。crypto/tls包提供了相同的接口和
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>go标准库03 路径与文件</title>
    <link href="https://t1ger.github.io/2017/09/28/go%E6%A0%87%E5%87%86%E5%BA%9303-%E8%B7%AF%E5%BE%84%E4%B8%8E%E6%96%87%E4%BB%B6/"/>
    <id>https://t1ger.github.io/2017/09/28/go标准库03-路径与文件/</id>
    <published>2017-09-28T04:22:53.000Z</published>
    <updated>2017-09-28T07:45:49.825Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><p>os包<br>提供系统相关函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">import (</div><div class="line"> &quot;fmt&quot;</div><div class="line"> &quot;os&quot;</div><div class="line">)</div><div class="line">func main() &#123;</div><div class="line"> dir, _ := os.Getwd()</div><div class="line"> fmt.Println(&quot;current dir:&quot;, dir)</div><div class="line"> fmt.Println(os.Geteuid())</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  此外,还有os.Getenv(),os.Chdir(),)os.Stat(),os.Chmod(),os.Chtime(),os.Environ(),os.Exit(),os.Expand(),os.ExpandEnv(),os.Hostname()等,详细介绍请查看<a href="https://golang.org/pkg/os/" target="_blank" rel="external">这里</a></p>
</li>
<li><p>io包<br>io包提供了大量的输入输出相关的函数,用来处理io.Reader和io.Writer.(*os.File类型的值能同时满足这两个接口的定义).另外,这个包还能用来创建内存中的同步管道.<br>io/ioutil包提供一些高级的辅助函数.<br>在io包中最重要的是两个接口：Reader和Writer接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">type Reader interface &#123;</div><div class="line">    Read(p []byte) (n int, err error)</div><div class="line">&#125;</div><div class="line"></div><div class="line">type Writer interface &#123;</div><div class="line">    Write(p []byte) (n int, err error)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  Read 将 len(p) 个字节读取到 p 中，当遇到任何错误（包括EOF）会立即返回已读取的字节数，函数结束会返回成功读取的字节数和任何错误。<br>Write 将 len(p) 字节数据从 p 写入底层的数据流，然后返回成功写入的字节数和任何错误。<br>从接口名称很容易猜到，一般地，Go中接口的命名约定：接口名以er结尾。<br>注意，这里并非强行要求，你完全可以不以 er 结尾。标准库中有些接口也不是以 er 结尾的</p>
</li>
<li><p>path包<br>path包用来操作unix风格的路径<br>path/filepath包提供了和path相同的函数,其目标是提供平台无关的路径处理,提供了filepath.Walk()函数来遍历读出一个给定路径下的所有文件和目录信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">        &quot;fmt&quot;</div><div class="line">        &quot;path/filepath&quot;</div><div class="line">)</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line"></div><div class="line">        absName, err := filepath.Abs(&quot;/a/b/c.txt&quot;)</div><div class="line">        if err != nil &#123;</div><div class="line">                fmt.Println(err)</div><div class="line">        &#125;</div><div class="line">        fmt.Println(absName)</div><div class="line"></div><div class="line">        baseName := filepath.Base(&quot;/a/b/c/e.txt&quot;)</div><div class="line">        fmt.Println(baseName)</div><div class="line"></div><div class="line">        p := &quot;../..//././//a/b/c.txt&quot;</div><div class="line">        pc := filepath.Clean(p)</div><div class="line">        fmt.Println(pc)</div><div class="line"></div><div class="line">        d := filepath.Dir(&quot;/a/b/c/d.txt&quot;)</div><div class="line">        fmt.Println(d)</div><div class="line"></div><div class="line">        e, _ := filepath.EvalSymlinks(&quot;/home/tiger/abc&quot;)</div><div class="line">        fmt.Println(e)</div><div class="line"></div><div class="line">        f := filepath.Ext(&quot;/tmp/1.txt&quot;)</div><div class="line">        fmt.Println(f)</div><div class="line"></div><div class="line">        m, _ := filepath.Glob(&quot;/usr/*&quot;)</div><div class="line">        fmt.Println(m)</div><div class="line"></div><div class="line">        fmt.Println(&quot;On Unix:&quot;)</div><div class="line">        fmt.Println(filepath.Join(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;))</div><div class="line">        fmt.Println(filepath.Join(&quot;a&quot;, &quot;b/c&quot;))</div><div class="line">        fmt.Println(filepath.Join(&quot;a/b&quot;, &quot;c&quot;))</div><div class="line">        fmt.Println(filepath.Join(&quot;a/b&quot;, &quot;/c&quot;))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  此外,还有 Split(), Walk()等</p>
</li>
</ul>
<ul>
<li>runtime包<br>runtime包含一些函数和类型,用来访问go语言的运行时系统<br>这里介绍几个跟平台有关的方法：NumCPU ,GOROOT ,GOOS ,GOMAXPROCS ,Gosched<br>func NumCPU() int<br>func GOROOT() string<br>func GOMAXPROCS(n int) int<br>func Gosched()<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">    &quot;fmt&quot;</div><div class="line">    &quot;runtime&quot;</div><div class="line">)</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    fmt.Println(&quot;cpus:&quot;, runtime.NumCPU())</div><div class="line">    fmt.Println(&quot;goroot:&quot;, runtime.GOROOT())</div><div class="line">    fmt.Println(&quot;os/platform:&quot;, runtime.GOOS)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<p>您的鼓励是我写作最大的动力</p>
<p>俗话说，投资效率是最好的投资。 如果您感觉我的文章质量不错，读后收获很大，预计能为您提高 10% 的工作效率，不妨小额捐助我一下，让我有动力继续写出更多好文章。</p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;os包&lt;br&gt;提供系统相关函数&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>go标准库02 时间与日期</title>
    <link href="https://t1ger.github.io/2017/09/28/go%E6%A0%87%E5%87%86%E5%BA%9302-%E6%97%B6%E9%97%B4%E4%B8%8E%E6%97%A5%E6%9C%9F/"/>
    <id>https://t1ger.github.io/2017/09/28/go标准库02-时间与日期/</id>
    <published>2017-09-28T02:56:14.000Z</published>
    <updated>2017-09-28T03:19:12.363Z</updated>
    
    <content type="html"><![CDATA[<p>Go具有良好的时间和日期管理功能。实际上，计算机只会维护一个挂钟时间(wall clock time)，这个时间是从某个固定时间起点到现在的时间间隔。时间起点的选择与计算机相关，但一台计算机的话，这一时间起点是固定的。其它的日期信息都是从这一时间计算得到的。</p>
<h5 id="time包"><a href="#time包" class="headerlink" title="time包"></a><b>time包</b></h5><ul>
<li><p>时间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">    &quot;fmt&quot;</div><div class="line">    &quot;time&quot;</div><div class="line">)</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    //时间戳</div><div class="line">    t := time.Now().Unix()</div><div class="line">    fmt.Print(t)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>time.sleep()<br>可以将程序置于休眠状态，直到某时间间隔之后再唤醒程序，让程序继续运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">    &quot;fmt&quot;</div><div class="line">    &quot;time&quot;</div><div class="line">)</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">        fmt.Println(&quot;start&quot;)</div><div class="line">        time.Sleep(time.Second * 10)  // sleep for 10 seconds</div><div class="line">        fmt.Println(&quot;wake up&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  当我们需要定时地查看程序运行状态时，就可以利用该方法。</p>
</li>
<li><p>time.After(time.Duration)<br>和Sleep差不多，在取出管道内容前不阻塞</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">    &quot;fmt&quot;</div><div class="line">    &quot;time&quot;</div><div class="line">)</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    fmt.Println(&quot;this is one&quot;)</div><div class="line">    tc:=time.After(time.Second)</div><div class="line">    fmt.Println(&quot;this is two&quot;)</div><div class="line">    fmt.Println(&quot;this is three&quot;)</div><div class="line">    &lt;-tc //阻塞中，直到取出tc管道里的数据 </div><div class="line">    fmt.Println(&quot;this is four&quot;)</div><div class="line">&#125;</div><div class="line">//打印this is one后，获得了一个空管道，这个管道1秒后会有数据进来</div><div class="line">//打印this is two</div><div class="line">//打印this is three</div><div class="line">//等待，直到可以取出管道的数据（取出数据的时间与获得tc管道的时间正好差1秒钟）</div><div class="line">//打印this is four</div></pre></td></tr></table></figure>
</li>
<li><p>time.AfterFunc(time.Duration,func())<br>和After差不多，意思是多少时间之后在goroutine line执行函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">    &quot;time&quot;</div><div class="line">    &quot;fmt&quot;</div><div class="line">)</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    f := func() &#123;</div><div class="line">        fmt.Println(&quot;Time out&quot;)</div><div class="line">    &#125;</div><div class="line">    time.AfterFunc(1*time.Second,f)</div><div class="line">    time.Sleep(2 * time.Second) //要保证主线比子线“死的晚”，否则主线死了，子线也等于死了</div><div class="line">&#125;</div><div class="line">//将一个间隔和一个函数给AfterFunc后</div><div class="line">//间隔时间过后，执行传入的函数</div></pre></td></tr></table></figure>
</li>
<li><p>Before &amp; After方法<br>判断一个时间点是否在另一个时间点的前面（后面），返回true或false</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">    &quot;time&quot;</div><div class="line">    &quot;fmt&quot;</div><div class="line">)</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    t1 := time.Now()</div><div class="line">    time.Sleep(time.Second)</div><div class="line">    t2 := time.Now()</div><div class="line">    a := t2.After(t1)</div><div class="line">    fmt.Println(a) //true</div><div class="line">    b := t2.Before(t1)</div><div class="line">    fmt.Println(b) //false</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>sub方法<br>两个时间点相减，获得时间差(Duration)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">    &quot;time&quot;</div><div class="line">    &quot;fmt&quot;</div><div class="line">)</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    t1 := time.Now()</div><div class="line">    time.Sleep(time.Second)</div><div class="line">    t2 :=time.Now()</div><div class="line">    d := t2.Sub(t1) //时间2减去时间1</div><div class="line">    fmt.Println(d)  //打印结果差不多为1.000123几秒，因为Sleep无法做到精确的睡1秒</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Add方法<br>拿一个时间点，add一个时长，获得另一个时间点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">    &quot;time&quot;</div><div class="line">    &quot;fmt&quot;</div><div class="line">)</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    t1 := time.Now()</div><div class="line">    t2 := t1.Add(time.Hour)</div><div class="line">    fmt.Println(t2)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<p>您的鼓励是我写作最大的动力</p>
<p>俗话说，投资效率是最好的投资。 如果您感觉我的文章质量不错，读后收获很大，预计能为您提高 10% 的工作效率，不妨小额捐助我一下，让我有动力继续写出更多好文章。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Go具有良好的时间和日期管理功能。实际上，计算机只会维护一个挂钟时间(wall clock time)，这个时间是从某个固定时间起点到现在的时间间隔。时间起点的选择与计算机相关，但一台计算机的话，这一时间起点是固定的。其它的日期信息都是从这一时间计算得到的。&lt;/p&gt;
&lt;h5
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>go标准库01 正则表达式(regexp包)</title>
    <link href="https://t1ger.github.io/2017/09/07/go%E6%A0%87%E5%87%86%E5%BA%9301-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-regexp%E5%8C%85/"/>
    <id>https://t1ger.github.io/2017/09/07/go标准库01-正则表达式-regexp包/</id>
    <published>2017-09-07T08:03:11.000Z</published>
    <updated>2017-09-07T10:07:22.386Z</updated>
    
    <content type="html"><![CDATA[<p>我将从正则表达式开始讲Go的标准库。正则表达式是文字处理中常用的工具，而且不需要额外的系统知识或经验。我们会把系统相关的包放在后面讲解。<br>正则表达式(regular expression)主要功能是从字符串(string)中通过特定的模式(pattern)，搜索想要找到的内容。</p>
<h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a><b>语法</b></h5><p>regexp包实现了正则表达式搜索。<br>正则表达式采用RE2语法（除了\c、\C），和Perl、Python等语言的正则基本一致<br>在go中使用正则表达式需要标准库中的一个包regexp</p>
<p>func Match(pattern string, b []byte) (matched bool, err error)<br>Match检查b中是否存在匹配pattern的子序列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line">import (</div><div class="line">    &quot;regexp&quot;</div><div class="line">    &quot;fmt&quot;</div><div class="line">)</div><div class="line">func main() &#123;</div><div class="line">    fmt.Println(regexp.Match(&quot;[0-9] &quot;, []byte(&quot;abcd5ef&quot;)))</div><div class="line">&#125;</div><div class="line"></div><div class="line">[tiger@bogon go]$ go run reg.go </div><div class="line">false &lt;nil&gt;</div></pre></td></tr></table></figure>
<p>如果你熟悉Linux或者Perl, 你应该已经熟悉正则表达式。当我们打开Linux shell的时候，可以用正则表达式去查找或着删除我们想要的文件，比如说：<br>$rm log[0-9][0-9].txt<br>这就是要删除类似于log02.txt的文件。log[0-9][0-9].txt所包含的信息是，以log开头，后面跟两个数字字符，之后跟有”.txt”的文件名。如果不符合条件的文件名，比如说:<br>log12.txt<br>log1.txt<br>log99.text<br>都不会被选中。<br>Perl中内建有正则表达式的功能，据说是所有正则表达式系统中最强的，这也是Perl成为系统管理员利器的一个原因。</p>
<h5 id="正则表达式的函数"><a href="#正则表达式的函数" class="headerlink" title="正则表达式的函数"></a><b>正则表达式的函数</b></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">func (re *Regexp) FindString(s string) string   //搜索整个字符串，直到发现符合的子字符串</div><div class="line">func (re *Regexp) MatchString(s string) bool   //MatchString类似Match，但匹配对象是字符串。</div></pre></td></tr></table></figure>
<p>可以从这两个函数中选择一个进行搜索。上面的例子中，我们如果使用regexp.MatchString()的话，则会得到False，因为字符串的起始为‘a’， 不符合’[0-9]’的要求。</p>
<p>我们还可以在搜索之后将搜索到的子字符串进行替换：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">func (re *Regexp) FindAllStringSubmatch(s string, n int) [][]string</div></pre></td></tr></table></figure></p>
<p>Find返回一个保管正则表达式re在b中的所有不重叠的匹配结果及其对应的（可能有的）分组匹配的结果的[][]string切片。如果没有匹配到，会返回nil。</p>
<p>此外，常用的正则表达式函数还有</p>
<p>func (re *Regexp) Split(s string, n int) []string<br>Split将re在s中匹配到的结果作为分隔符将s分割成多个字符串，并返回这些正则匹配结果之间的字符串的切片。</p>
<p>func (re *Regexp) FindAllString(s string, n int) []string<br>Find返回保管正则表达式re在b中的所有不重叠的匹配结果的[]string切片。如果没有匹配到，会返回nil。</p>
<h5 id="写一个正则表达式"><a href="#写一个正则表达式" class="headerlink" title="写一个正则表达式"></a><b>写一个正则表达式</b></h5><p>关键在于将信息写成一个正则表达式。我们先看正则表达式的常用语法</p>
<ul>
<li><p>单个字符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">.          任意的一个字符</div><div class="line">a|b        字符a或字符b</div><div class="line">[afg]      a或者f或者g的一个字符        </div><div class="line">[0-4]      0-4范围内的一个字符</div><div class="line">[a-f]      a-f范围内的一个字符</div><div class="line">[^m]       不是m的一个字符</div><div class="line">\s         一个空格</div><div class="line">\S         一个非空格</div><div class="line">\d         [0-9]</div><div class="line">\D         [^0-9]</div><div class="line">\w         [0-9a-zA-Z]</div><div class="line">\W         [^0-9a-zA-Z]</div></pre></td></tr></table></figure>
</li>
<li><p>重复<br>紧跟在单个字符之后，表示多个这样类似的字符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">*         重复 &gt;=0 次</div><div class="line">+         重复 &gt;=1 次</div><div class="line">?         重复 0或者1 次</div><div class="line">&#123;m&#125;       重复m次。比如说 a&#123;4&#125;相当于aaaa，再比如说[1-3]&#123;2&#125;相当于[1-3][1-3]</div><div class="line">&#123;m, n&#125;    重复m到n次。比如说a&#123;2, 5&#125;表示a重复2到5次。小于m次的重复，或者大于n次的重复都不符合条件。</div><div class="line"></div><div class="line">正则表达          相符的字符串举例</div><div class="line">[0-9]&#123;3,5&#125;       9678</div><div class="line">a?b              b</div><div class="line">a+b              aaaaab</div></pre></td></tr></table></figure>
</li>
<li><p>位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">^         字符串的起始位置</div><div class="line">$         字符串的结尾位置</div><div class="line"></div><div class="line">正则表达          相符的字符串举例        不相符字符串</div><div class="line">^ab.*c$          abeec               cabeec</div></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<p>您的鼓励是我写作最大的动力</p>
<p>俗话说，投资效率是最好的投资。 如果您感觉我的文章质量不错，读后收获很大，预计能为您提高 10% 的工作效率，不妨小额捐助我一下，让我有动力继续写出更多好文章。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我将从正则表达式开始讲Go的标准库。正则表达式是文字处理中常用的工具，而且不需要额外的系统知识或经验。我们会把系统相关的包放在后面讲解。&lt;br&gt;正则表达式(regular expression)主要功能是从字符串(string)中通过特定的模式(pattern)，搜索想要找
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>go标准库--走马观花</title>
    <link href="https://t1ger.github.io/2017/09/07/go%E6%A0%87%E5%87%86%E5%BA%93-%E8%B5%B0%E9%A9%AC%E8%A7%82%E8%8A%B1/"/>
    <id>https://t1ger.github.io/2017/09/07/go标准库-走马观花/</id>
    <published>2017-09-07T04:20:13.000Z</published>
    <updated>2017-09-07T05:45:48.602Z</updated>
    
    <content type="html"><![CDATA[<p>Go有一套很有用的标准库(standard library)。它是Go的一个组成部分。这些标准库是Go为你准备好的利器，可以让编程事半功倍。</p>
<p>我将根据我个人的使用经验中，挑选出标准库三个方面的包(package)介绍：</p>
<ul>
<li>go增强</li>
<li>系统互动</li>
<li>网络</li>
</ul>
<h5 id="go增强"><a href="#go增强" class="headerlink" title="go增强"></a><b>go增强</b></h5><p>go自身的已有的一些功能可以随着标准库的使用而得到增强</p>
<ul>
<li><p>文字处理<br>Go的strings包提供了对字符串进行处理的方法.更进一步，通过标准库中的regexp包,Go可以用正则表达式(regular expression)来处理字符串。<br>正则表达式是一个字符串模板。Go可以从字符中搜查符合该模板的部分，或者对这一部分替换成其它内容。比如你可以搜索一个文本中所有的数字。正则表达式的关键在于根据自己的需要构成模板。<br>此外，Go标准库还为字符串的输出提供更加丰富的格式，比如: strconv,bytes,unicode</p>
</li>
<li><p>数据结构与算法<br>数据结构是数据组织和存储的逻辑形式,为了有效的使用资源,在时间和空间上有效的算法可以帮助我们,Go标准库提供了sort,inedex/suffixary,container<br>sort 包包含基本的排序方法，支持切片数据排序以及用户自定义数据集合排序<br>index/suffixary 包实现了后缀数组相关算法以支持许多常见的字符串操作<br>container 包提供了对heap、list和ring这3种数据结构的底层支持。任何实现了相应接口的数据结构都可以调用该结构的方法</p>
</li>
<li><p>日期和时间<br>日期和时间的管理并不复杂，但容易犯错。经常会遇到日期和时间相关的操作,比如：格式化日期和时间，解析一个日期时间字符串等。Go语言通过标准库 time 包处理日期和时间相关的问题<br>time包提供了用于测量时间、解析和格式化日期，日期/时间以及时间值的函数。time.After()函数可用于在特定纳秒后，向通道 (channel)发送当前时间。time.Tick()和time.NewTicker()函数可用于提供一个通道，它会返回在特定时间间隔后将 ‘tick’发送到该通道上。time.Time结构具有一些方法，可提供当前时间，将data/time格式化为一个字符串以及解析data /time</p>
</li>
<li><p>数学运算<br>math/big包提供了无限大(实际受限于内存)整型数(big.Int)以及有理数(big.Rat)。math包提供了所有标准数学函数(基于float64)以及一些标准常量。math/cmplx包提供一些用于复数计算的标准函数(基于complex128)<br>此外,math/rand包提供许多有用的伪随机数生成函数，包括返回一个随机整型数的rand.Int()以及rand.Intn(n)，后者返回[0,n]范围内的一个随机整数。crypto/rand包中有一个函数，可用于产生加密的强伪随机数字</p>
</li>
<li><p>存储<br>在数据交换方面，有很多成熟的协议可以使用，常用的有：JSON、XML等,Go 语言提供了解析它们的标准库；同时，为了方便 Go 程序直接数据交换，Go 专门提供了 gob 这种交换协议<br>此外，标准库中还支持基本的数据库功能(database/sql包),csv格式的文件也有相应的处理包</p>
</li>
<li><p>数据压缩与归档<br>Go 标准库实现了一些最流行的压缩标准。zlib 和 gzip 提供了 GNU zip 库，bzip2 用于读写 bzip2 格式<br>标准库提供了 LZW 压缩算法（串表压缩算法）的实现，该算法常用的文件格式：GIF 和 PDF。<br>标准库还提供一些包管理归档(archive)格式,archive/tar 读写 UNIX 磁带归档格式,archive/zip 根据 zip 格式来处理归档</p>
</li>
</ul>
<h5 id="系统互动"><a href="#系统互动" class="headerlink" title="系统互动"></a><b>系统互动</b></h5><ul>
<li><p>操作系统<br>Go 的标准库提供了很多工具，可以处理文件系统中的文件、构造和解析文件名等,path包提供的函数用于操作Unix样式路径<br>runtime包包含了许多函数和类型用于访问Go的运行时系统</p>
</li>
<li><p>进程与线程<br>在Go中提供os 包及其子包 os/exec 提供了创建进程的方法,同时,我们知道在 Linux 中，通过系统调用 clone() 来实现线程的,在 Go 中，通过 clone() 系统调用来创建线程</p>
</li>
</ul>
<h5 id="网络"><a href="#网络" class="headerlink" title="网络"></a><b>网络</b></h5><ul>
<li>网络包<br>Go标准库中有许多包用于支持网络以及相关方面的编程。net包提供的函数和类型可用于使用Unix域以及网络socket通信、TCP/IP和UDP编程<br>net/http包充分利用了net包，并提供了解析HTTP请求和应答的功能，并提供了一个基本的HTTP客户端。net/http包也包含一个易于扩展的HTTP server。net/url包提供了URL解析和查询转义<br>标准库中还包含其他一些其他高层次的网络包。一个是net/rpc(远程过程调用)包，它允许一个服务端提供导出可被客户端调用的方法的对象。另外一个是net/smtp(简单邮件传输协议)包，可用于发送email</li>
</ul>
<p>以上的介绍比较粗糙，只希望能为大家提供一个了解标准库的入口。欢迎大家一起分享标准库的使用经验。</p>
<hr>
<p>您的鼓励是我写作最大的动力</p>
<p>俗话说，投资效率是最好的投资。 如果您感觉我的文章质量不错，读后收获很大，预计能为您提高 10% 的工作效率，不妨小额捐助我一下，让我有动力继续写出更多好文章。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Go有一套很有用的标准库(standard library)。它是Go的一个组成部分。这些标准库是Go为你准备好的利器，可以让编程事半功倍。&lt;/p&gt;
&lt;p&gt;我将根据我个人的使用经验中，挑选出标准库三个方面的包(package)介绍：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;go增强&lt;/l
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Go进阶07 defer,panic,recover</title>
    <link href="https://t1ger.github.io/2017/09/04/Go%E8%BF%9B%E9%98%B607-defer-panic-recover/"/>
    <id>https://t1ger.github.io/2017/09/04/Go进阶07-defer-panic-recover/</id>
    <published>2017-09-04T09:39:56.000Z</published>
    <updated>2017-09-04T10:12:22.322Z</updated>
    
    <content type="html"><![CDATA[<h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a><b>概念</b></h5><ul>
<li>defer<br>在函数返回前执行一些操作,表达式通常用来处理一些清理和释放资源的操作</li>
<li>panic<br>表示非常严重的不可恢复的错误,panic一般会导致程序挂掉(除非recover),重要的一点是,即使函数执行的时候panic了,函数不往下走了，运行时并不是立刻向上传递panic,而是到defer那,等defer的东西都跑完了,panic再向上传递</li>
<li>recover<br>Go语言提供了recover内置函数,一旦panic,逻辑就会走到defer那,那我们就在defer那等着,调用recover函数将会捕获到当前的panic(如果有的话),被捕获到的panic就不会向上传递了<br>要注意的是，recover之后，逻辑并不会恢复到panic那个点去，函数还是会在defer之后返回</li>
</ul>
<h5 id="用法"><a href="#用法" class="headerlink" title="用法"></a><b>用法</b></h5><p>首先我们来看下defer,在官方的文档中看到defer的执行顺序是逆序的，也就是先进后出的顺序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">for i :=0; i&lt; 5; i++ &#123;</div><div class="line">    defer fmt.Printf(&quot;%d &quot;, i)</div><div class="line">&#125;</div><div class="line"></div><div class="line">[tiger@bogon go]$ go run defer.go   </div><div class="line">4 3 2 1 0</div></pre></td></tr></table></figure></p>
<p>如何从panic中恢复呢? recover()函数用于获取/拦截panic,仅当在一个defer函数中被完成时.下面来看三个例子<br>错误的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line">import fmt</div><div class="line">func main() &#123; </div><div class="line">    recover()         //don&apos;t do anything</div><div class="line">    panic(&quot;not good&quot;)</div><div class="line">    recover()        //will not be executed</div><div class="line">    fmt.Println(&quot;ok&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>正确的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line">import fmt</div><div class="line">func main() &#123;</div><div class="line">    defer func() &#123;</div><div class="line">	    fmt.Println(&quot;recovered:&quot;,recover())</div><div class="line">	&#125;()</div><div class="line">	</div><div class="line">    panic(&quot;not good&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>失败的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line">import fmt</div><div class="line">func doRecover()&#123;</div><div class="line">    fmt.Println(&quot;recovered =&gt;&quot;, recover()) //prints: recovered =&gt; &lt;nil&gt;</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    defer func() &#123;</div><div class="line">        doRecover() //panic is not recovered</div><div class="line">	&#125;()</div><div class="line">    panic(&quot;not good&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a><b>总结</b></h5><p>defer可以多次，这样形成一个defer栈，后defer的语句在函数返回时将先被调用<br>panic一般会导致程序挂掉<br>recover()的调用仅当它在defer函数中被直接调用时才有效<br>recover之后，逻辑并不会恢复到panic那个点去，函数还是会在defer之后返回</p>
<hr>
<p>您的鼓励是我写作最大的动力</p>
<p>俗话说，投资效率是最好的投资。 如果您感觉我的文章质量不错，读后收获很大，预计能为您提高 10% 的工作效率，不妨小额捐助我一下，让我有动力继续写出更多好文章。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;&lt;b&gt;概念&lt;/b&gt;&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;defer&lt;br&gt;在函数返回前执行一些操作,表达式通常用来处理一些清理和释放资源的操作&lt;/li&gt;
&lt;li&gt;pani
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Go进阶06 iota</title>
    <link href="https://t1ger.github.io/2017/09/04/Go%E8%BF%9B%E9%98%B606-iota/"/>
    <id>https://t1ger.github.io/2017/09/04/Go进阶06-iota/</id>
    <published>2017-09-04T04:45:34.000Z</published>
    <updated>2017-09-04T08:22:30.391Z</updated>
    
    <content type="html"><![CDATA[<h5 id="iota简介"><a href="#iota简介" class="headerlink" title="iota简介"></a><b>iota简介</b></h5><p>iota 是golang的常量计数器,只能在常量的表达式中使用.<br>iota在const关键字出现时将被重置为0,const中每新增一行将使iota计数一次<br>iota可以简化定义,经常用在枚举的时候</p>
<h5 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a><b>常见用法</b></h5><ul>
<li>iota只能在常量表达式中使用</li>
<li><p>每次const出现时,iota会初始化为0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const a = iota  // a = 0</div><div class="line">const (</div><div class="line">    b = iota    // b = 0 </div><div class="line">    c 		// c = 1</div><div class="line">)</div></pre></td></tr></table></figure>
</li>
<li><p>自定义类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const (</div><div class="line">    red = iota</div><div class="line">    blue</div><div class="line">    green</div><div class="line">)</div></pre></td></tr></table></figure>
</li>
<li><p>可跳过的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">const (</div><div class="line">    red = iota  // 0</div><div class="line">    blue        // 1 </div><div class="line">    green       // 2</div><div class="line">    - </div><div class="line">    -</div><div class="line">    yellow      // 5</div><div class="line">    black       // 6</div><div class="line">)</div></pre></td></tr></table></figure>
</li>
<li><p>定义数量级</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">type ByteSize float64</div><div class="line">const(</div><div class="line">    _     = iota                 // ignore first value by assigning to blank identifier</div><div class="line">    KB ByteSize = 1 &lt;&lt; (10*iota) // 1&lt;&lt;(10*1)</div><div class="line">    MB                           // 1&lt;&lt;(10*2)</div><div class="line">    GB                           // 1&lt;&lt;(10*3)</div><div class="line">    TB                           // 1&lt;&lt;(10*4)</div><div class="line">    PB                           // 1&lt;&lt;(10*5)</div><div class="line">    EB                           // 1&lt;&lt;(10*6)</div><div class="line">    ZB                           // 1&lt;&lt;(10*7)</div><div class="line">    YB                           // 1&lt;&lt;(10*8)</div><div class="line">)</div></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<p>您的鼓励是我写作最大的动力</p>
<p>俗话说，投资效率是最好的投资。 如果您感觉我的文章质量不错，读后收获很大，预计能为您提高 10% 的工作效率，不妨小额捐助我一下，让我有动力继续写出更多好文章。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;iota简介&quot;&gt;&lt;a href=&quot;#iota简介&quot; class=&quot;headerlink&quot; title=&quot;iota简介&quot;&gt;&lt;/a&gt;&lt;b&gt;iota简介&lt;/b&gt;&lt;/h5&gt;&lt;p&gt;iota 是golang的常量计数器,只能在常量的表达式中使用.&lt;br&gt;iota在const关
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Go进阶05 fallthrough</title>
    <link href="https://t1ger.github.io/2017/09/04/Go%E8%BF%9B%E9%98%B605-fallthrough/"/>
    <id>https://t1ger.github.io/2017/09/04/Go进阶05-fallthrough/</id>
    <published>2017-09-04T03:50:20.000Z</published>
    <updated>2017-09-04T10:25:28.264Z</updated>
    
    <content type="html"><![CDATA[<h5 id="fallthrough用法"><a href="#fallthrough用法" class="headerlink" title="fallthrough用法"></a><b>fallthrough用法</b></h5><p>Go里边的switch默认每个case匹配成功后不会自动向下执行其他case,直接跳出switch,fallthrough强制执行后边的case代码,fallthrough不对下一条的case表达式进行判断<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    switch a:=10; &#123;</div><div class="line">    case a &gt;= 9:</div><div class="line">        fmt.Println(&quot;&gt;=9&quot;)</div><div class="line">        fallthrough</div><div class="line">    case a &gt;= 10: </div><div class="line">        fmt.Println(&quot;&gt;=10&quot;)</div><div class="line">        fallthrough</div><div class="line">    case a &gt;= 15:</div><div class="line">        fmt.Println(&quot;&gt;=15&quot;)</div><div class="line">        fallthrough</div><div class="line">    case a &gt;= 20:</div><div class="line">        fmt.Println(&quot;&gt;=20&quot;)</div><div class="line">        fallthrough</div><div class="line">    default:</div><div class="line">        fmt.Println(&quot;default&quot;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">[tiger@bogon go]$ go run fallthrough.go </div><div class="line">&gt;=9</div><div class="line">&gt;=10</div><div class="line">&gt;=15</div><div class="line">&gt;=20</div><div class="line">default</div></pre></td></tr></table></figure></p>
<p>fallthrough可不可以放到最后一个呢,我们在default里添加之后,我们运行一下看看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[tiger@bogon go]$ go run fallthrough.go </div><div class="line"># command-line-arguments</div><div class="line">./fallthrough.go:21: cannot fallthrough final case in switch</div></pre></td></tr></table></figure>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a><b>总结</b></h5><p>fallthrough:Go里面switch默认相当于每个case最后带有break，匹配成功后不会自动向下执行其他case，而是跳出整个switch, 但是可以使用fallthrough强制执行后面的case代码<br>fallthrough不能用在switch最后一个分支</p>
<hr>
<p>您的鼓励是我写作最大的动力</p>
<p>俗话说，投资效率是最好的投资。 如果您感觉我的文章质量不错，读后收获很大，预计能为您提高 10% 的工作效率，不妨小额捐助我一下，让我有动力继续写出更多好文章。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;fallthrough用法&quot;&gt;&lt;a href=&quot;#fallthrough用法&quot; class=&quot;headerlink&quot; title=&quot;fallthrough用法&quot;&gt;&lt;/a&gt;&lt;b&gt;fallthrough用法&lt;/b&gt;&lt;/h5&gt;&lt;p&gt;Go里边的switch默认每个case
    
    </summary>
    
    
  </entry>
  
</feed>
