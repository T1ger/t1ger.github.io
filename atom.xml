<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>t1ger的茶馆</title>
  <subtitle>头顶有光终是幻，足下生云未是仙</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://t1ger.github.io/"/>
  <updated>2016-09-14T01:58:32.729Z</updated>
  <id>https://t1ger.github.io/</id>
  
  <author>
    <name>t1ger</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://t1ger.github.io/2016/09/14/google9a8feb742f4276dd/"/>
    <id>https://t1ger.github.io/2016/09/14/google9a8feb742f4276dd/</id>
    <published>2016-09-14T01:59:03.060Z</published>
    <updated>2016-09-14T01:58:32.729Z</updated>
    
    <content type="html"><![CDATA[google-site-verification: google9a8feb742f4276dd.html]]></content>
    
    <summary type="html">
    
      google-site-verification: google9a8feb742f4276dd.html
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>mysql 字段自定义排序问题</title>
    <link href="https://t1ger.github.io/2016/09/13/mysql-%E5%AD%97%E6%AE%B5%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/"/>
    <id>https://t1ger.github.io/2016/09/13/mysql-字段自定义排序问题/</id>
    <published>2016-09-13T08:13:27.000Z</published>
    <updated>2016-09-13T08:43:12.890Z</updated>
    
    <content type="html"><![CDATA[<p>今天碰到一个问题，指定mysql字段自定义排序</p>
<pre><code>SELECT id FROM table  WHERE `id` IN (40593,6352,38120,56049,56050,56051);
</code></pre><p>外事不决问google，经过搜索，网上的建议是使用FIELD()和FIND_IN_SET():</p>
<pre><code>SELECT id FROM table  WHERE `id` IN (40593,6352,38120,56049,56050,56051) order by FIELD(id,6352,38120)desc ;

SELECT id FROM table  WHERE `id` IN (40593,6352,38120,56049,56050,56051) order by FIND_IN_SET(username,&quot;6352,38120&quot;);
</code></pre><p>继续google之,又找到一个建议，使用substring_index：</p>
<p>substring_index(str,delim,count) str:要处理的字符串 delim:分隔符 count:计数</p>
<p>str=www.google.com<br>substring_index(str,’.’,1)<br>结果是：www<br>substring_index(str,’.’,2)<br>结果是：www.google<br>即如果count是正数，那么就是从左往右数，第N个分隔符的左边的全部内容<br>相反，如果是负数，那么就是从右边开始数，第N个分隔符右边的所有内容，如：<br>substring_index(str,’.’,-2)<br>结果为：google.com<br>有人会说，如果我要中间的google怎么办？<br>很简单的，两个方向：<br>1、从右数第二个分隔符的右边全部，再从左数的第一个分隔符的左边：<br>substring_index(substring_index(str,’.’,-2),’.’,1);<br>2、你懂得！</p>
<pre><code>SELECT id FROM table  WHERE `id` IN (40593,6352,38120,56049,56050,56051) order by substring_index(&apos;40593&apos;,username,1);
</code></pre><p>完美解决，更多详细讨论请移步<a href="http://dev.mysql.com/doc/refman/5.7/en/sorting-rows.html" target="_blank" rel="external">官网讨论</a></p>
<hr>
<p>您的鼓励是我写作最大的动力</p>
<p>俗话说，投资效率是最好的投资。 如果您感觉我的文章质量不错，读后收获很大，预计能为您提高 10% 的工作效率，不妨小额捐助我一下，让我有动力继续写出更多好文章。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天碰到一个问题，指定mysql字段自定义排序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT id FROM table  WHERE `id` IN (40593,6352,38120,56049,56050,56051);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;外事不决问goo
    
    </summary>
    
    
      <category term="mysql" scheme="https://t1ger.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>五分钟快速了解 MySQL8新特性</title>
    <link href="https://t1ger.github.io/2016/09/13/%E4%BA%94%E5%88%86%E9%92%9F%E5%BF%AB%E9%80%9F%E4%BA%86%E8%A7%A3-MySQL8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://t1ger.github.io/2016/09/13/五分钟快速了解-MySQL8新特性/</id>
    <published>2016-09-13T02:42:57.000Z</published>
    <updated>2016-09-13T03:29:54.744Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL Community Server 8.0.0 dmr(Development Milestone Release)终于发布了，8.0的发布，可以说是MySQL来到了一个崭新的时代。MySQL终于废弃了MyISAM引擎，完成了MySQL的完美转身。</p>
<p>MySQL的来历</p>
<p>MySQL是一个小型关系型数据库管理系统，开发者为瑞典MySQL AB公司。在2008年1月16号被Sun公司收购。而2009年,SUN又被Oracal收购。</p>
<p>MySQL的标志趣闻</p>
<p>MySQL的海豚标志的名字叫“sakila”，它是由MySQL AB的创始人从用户在“海豚命名”的竞赛中建议的大量的名字表中选出的。获胜的名字是由来自非洲斯威士兰的开源软件开发者Ambrose Twebaze提供。根据Ambrose所说，Sakila来自一种叫SiSwati的斯威士兰方言，也是在Ambrose的家乡乌干达附近的坦桑尼亚的Arusha的一个小镇的名字。    </p>
<p>这里吐槽一下的是MySQL的体积是越来越大了，几乎1G的大小让用户情何以堪呀，好怀念以前的时光呀。自从oracle收购了MySQL以后，体积是越来越向oracle看齐了。</p>
<p>闲言少续，让我们一起看看MySQL的变化吧：</p>
<ul>
<li>账户管理，官方正式支持MySQL的ROLE了，grant tables 现在是InnoDB引擎了，放弃了先前的MyISAM。</li>
<li>参数持久化，支持 SET语句并将参数写入data 目录下MySQLd-auto.cnf。在MySQL重启时，MySQL将优先读取此文件。</li>
<li>MySQL的初始化， MySQL将使用–initialize or –initialize-insecure 代替 MySQL_install_db</li>
<li>The .frm 元数据不在存在，元数据文件将存储在数据字典表中。</li>
<li>MySQL 现在支持 invisible indexes。这对dba来说可是个福音，小伙伴们可以不用移除index而放心测试查询性能了。</li>
<li>mysqld 不在支持  –partition and –skip-partition 选项。</li>
<li>持久化自增值。通过将 auto-increment 值写入redo 日志来持久化自增值，优雅的解决了这一历史问题。</li>
</ul>
<p>上述只是8.0改进的一小部分，感兴趣的同学请移步官网。</p>
<hr>
<p>您的鼓励是我写作最大的动力</p>
<p>俗话说，投资效率是最好的投资。 如果您感觉我的文章质量不错，读后收获很大，预计能为您提高 10% 的工作效率，不妨小额捐助我一下，让我有动力继续写出更多好文章。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MySQL Community Server 8.0.0 dmr(Development Milestone Release)终于发布了，8.0的发布，可以说是MySQL来到了一个崭新的时代。MySQL终于废弃了MyISAM引擎，完成了MySQL的完美转身。&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="https://t1ger.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>提高工作效率之vim篇</title>
    <link href="https://t1ger.github.io/2016/09/09/%E6%8F%90%E9%AB%98%E5%B7%A5%E4%BD%9C%E6%95%88%E7%8E%87%E4%B9%8Bvim%E7%AF%87/"/>
    <id>https://t1ger.github.io/2016/09/09/提高工作效率之vim篇/</id>
    <published>2016-09-09T06:50:23.000Z</published>
    <updated>2016-09-09T07:31:10.492Z</updated>
    
    <content type="html"><![CDATA[<h3 id="启动及关闭-Vi-Vim"><a href="#启动及关闭-Vi-Vim" class="headerlink" title="启动及关闭 Vi/Vim"></a>启动及关闭 Vi/Vim</h3><pre><code>1. vi 打开 Vi/Vim
   vi &lt;file&gt; 打开 Vi/Vim 并加载文件 &lt;file&gt;
2. ZQ 无条件退出 
   :q! 无条件退出
   ZZ 存盘并退出
   :wq 存盘并退出
3. :m,nw &lt;file&gt; 将 m 行到 n 行部分的内容保存到文件 &lt;file&gt; 中 
   :m,nw &gt;&gt; &lt;file&gt; 将 m 行到 n 行的内容添加到文件 &lt;file&gt; 的末尾
</code></pre><p>在使用 Vi/Vim 的时候，有时想临时退出 Vi/Vim，转到 shell 环境里去做一些操作，等这些操作结束后，再继续回到刚才的 Vi/Vim 状态。<br>有两种方法可以可以实现临时退出 Vi/Vim、进入 shell 环境后再回来的要求：<br><strong>方法一：使用 Ctrl-z 以及 fg 这两个命令组合。</strong></p>
<ul>
<li>Ctrl-z 命令将当前的 Vi/Vim 进程放到后台执行，之后 shell 环境即可为你所用；fg 命令则将位于后台的 Vi/Vim 进程放到前台执行，这样我们就再次进入 Vi/Vim 操作界面并恢复到原先的编辑状态。</li>
</ul>
<p><strong>方法二：使用行命令 :sh。</strong> </p>
<ul>
<li>在 Vi/Vim 的正常模式下输入 :sh即可进入 Linux/Unix shell 环境。在要返回到 Vi/Vim 编辑环境时，输入 exit 命令即可。</li>
</ul>
<h3 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h3><p>要正确高效的运用 Vi/Vim 的各种操作，一定要把握这一原则: <strong>先定单位再定量。</strong> 操作对象的范围计算公式为：操作范围 = 操作次数 * 操作单位。比如：5h 命令左移 5 个字符，8w 命令右移 8 个单词。</p>
<p>Vi/Vim 中操作单位有很多，按从小到大的顺序为（括号内为相应的操作命令）：字符（h、l）→ 单词 (w、W、b、B、e) → 行 (j、k、0、^、$、:n) → 句子（(、)）→ 段落（{、}）→ 屏 (H、M、L) → 页（Ctrl-f、Ctrl-b、Ctrl-u、Ctrl-d) → 文件（G、gg、:0、:$）。</p>
<p>除了这些基本单位之外，还有 %（跳转到与之匹配的括号处），`.（跳转到最近修改过的位置并定位编辑点）, ‘.（跳转到最近修改过的位置但不定位编辑点）这三个命令也非常重要，在 Vi/Vim 中灵活使用会极大提高效率。% 除用于光标移动之后，还可用于检测源码中各种括号的匹配情况。</p>
<pre><code>1. fa → 到下一个为a的字符处,你也可以fs到下一个为s的字符
2. 0 移到当前行开头 
   ^ 移到当前行的第一个非空字符
   $ 移到当前行末尾
   :n 移动到第 n 行
3. ) 移动到当前句子的末尾
   ( 移动到当前句子的开头
4. } 移动当前段落的末尾
   { 移到当前段落的开头
5. H 移动到屏幕的第一行
   M 移动到屏幕的中间一行
   L 移动到屏幕的最后一行
6. Ctrl-f 向前滚动一页
   Ctrl-b 向后滚动一页
   Ctrl-u 向前滚动半页
   Ctrl-d 向后滚动半页
7. G 移动到文件末尾
   gg 移动到文件开头
   :0 移动到文件第一行
   :$ 移动到文件最后一行
</code></pre><hr>
<p>除了这些基本单位之外，还有 %（跳转到与之匹配的括号处），`.（跳转到最近修改过的位置并定位编辑点）, ‘.（跳转到最近修改过的位置但不定位编辑点）这三个命令也非常重要，在 Vi/Vim 中灵活使用会极大提高效率。% 除用于光标移动之后，还可用于检测源码中各种括号的匹配情况。</p>
<hr>
<h3 id="文本编辑"><a href="#文本编辑" class="headerlink" title="文本编辑"></a>文本编辑</h3><p>与光标移动一样，Vi/Vim 中关于编辑操作的命令也比较多，但操作单位要比移动光标少得多。按从小到大的顺序为（括号内为相应的操作命令）：字符 （x、c、s、r、i、a）→ 单词 (cw、cW、cb、cB、dw、dW、db、dB) → 行 (dd、d0、d$、I、A、o、O) → 句子（(、)）→ 段落（{、}）。这些操作单位有些可以加操作次数。操作对象的范围计算公式为：操作范围 = 操作次数 * 操作单位。比如：d3w 命令删除三个单词，10dd 命令删除十行。</p>
<pre><code>1. dd 删除当前行
   d0 删除从当前光标开始到行末的内容
   d$ 删除从当前光标开始到行末的内容
2. d) 删除当前句子从光标位置开始到句末的内容
   d( 删除当前句子从光标位置开始到句首的内容
3. d} 删除当前段落从光标位置开始到段末的内容
   d{ 删除当前段落从光标位置开始到段首的内容
4. yw 复制当前单词从光标开始的部分
   yy 复制光标所在行的所有字符;p 将最后一个删除或复制文本放在当前字符 
5. u 撤消更改
   Ctrl-R 重做更改
6. . 重复上次操作(. 为小数点（dot）,有点象 MS Office 的格式刷)
7. :%!nl 在所有非空行前加入行号 
   :%!nl -ba 在所有行前加入行号(利用 Linux 命令 nl 来实现的)
8. Ctrl-g 显示当前编辑文件名及行数
9. Ctrl-p 自动补全(在编写代码的时候非常有用.比如，输入 prin 后按 Ctrl-p 将自动帮你输入 printf 函数名后面的部分，同时将相关备选函数在底下列出来.)
</code></pre><h3 id="文本搜索与替换"><a href="#文本搜索与替换" class="headerlink" title="文本搜索与替换"></a>文本搜索与替换</h3><p>Vi/Vim 用于文本搜索的主要有下面的三个基本命令：</p>
<pre><code>1. / 在文件中向前搜索(可配合操作数使用，比如 3/str 向前搜索字串 str 并将光标移到第三个找到的串)
2. ? 在文件中向后搜索
3. n 搜索下一个 N 反向搜索下一个
</code></pre><p>除这三个基本命令之外，还有以下三个非常有效快捷的与搜索查找有关的命令：</p>
<pre><code>1. * 在文件中向前搜索当前光标所在的单词
   # 在文件中向后搜索当前光标所在的单词
2. q/ 显示搜索命令历史的窗口, q? 显示搜索命令历史的窗口
</code></pre><p>关于替换主是要结合搜索使用行命令来实现，命令格式为：</p>
<pre><code>:m,ns/str1/str2/g 将 m 行到 n 行中的字串 str1 全部替换为字串 str2。
在众多使用正则表达式进行替换的命令中，平时需要掌握的一个命令是如何快速去除 ^M 字符。
在 Vi/Vim 中使用替换命令 :1,$s/^M//g即可以很容易地快速去掉 ^M 字符。这里需要注意的是 ^M 是使用 Ctrl-v、Ctrl-m 输入的。
</code></pre><h3 id="Vi-Vim-设置"><a href="#Vi-Vim-设置" class="headerlink" title="Vi/Vim 设置"></a>Vi/Vim 设置</h3><pre><code>1. 设置行号显示与否
   :set number 显示行号
   :set no number 取消行号显示
   命令的简写形式：
   :set nu 
   :set no nu
2. 设置自动缩进 
   :set autoindent 设置自动缩进 
   :set no autoindent 取消自动缩进设置
   命令的简写形式：
   :set ai 
   :set no ai
3. 设置缩进宽度 :set shiftwidth=4 设置缩进宽度为 4 
   命令的简写形式：
   :set sw=4
</code></pre><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>vim 编辑器是一个极其强大的工具，本文提供了一些技巧和诀窍，希望能够帮助您更高效地编辑文件。请记住，vim 还有更多不太为人所知的特性。</p>
<hr>
<p>您的鼓励是我写作最大的动力</p>
<p>俗话说，投资效率是最好的投资。 如果您感觉我的文章质量不错，读后收获很大，预计能为您提高 10% 的工作效率，不妨小额捐助我一下，让我有动力继续写出更多好文章。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;启动及关闭-Vi-Vim&quot;&gt;&lt;a href=&quot;#启动及关闭-Vi-Vim&quot; class=&quot;headerlink&quot; title=&quot;启动及关闭 Vi/Vim&quot;&gt;&lt;/a&gt;启动及关闭 Vi/Vim&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;1. vi 打开 Vi/Vim
   vi 
    
    </summary>
    
    
      <category term="linux" scheme="https://t1ger.github.io/tags/linux/"/>
    
      <category term="vim" scheme="https://t1ger.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>nginx proxy_pass常用知识点解析</title>
    <link href="https://t1ger.github.io/2016/09/08/nginx-proxy-pass%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A7%A3%E6%9E%90/"/>
    <id>https://t1ger.github.io/2016/09/08/nginx-proxy-pass常用知识点解析/</id>
    <published>2016-09-08T03:55:45.000Z</published>
    <updated>2016-09-08T07:27:28.824Z</updated>
    
    <content type="html"><![CDATA[<h3 id="proxy-pass-指令-解析"><a href="#proxy-pass-指令-解析" class="headerlink" title="proxy_pass 指令/ 解析"></a>proxy_pass 指令<code>/</code> 解析</h3><p>首先，我们先上两个例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">location ^~ /test/</div><div class="line">	&#123;</div><div class="line">	proxy_pass http://www.test.com;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">location ^~ /test/</div><div class="line">	&#123;</div><div class="line">	proxy_pass http://www.test.com/;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>区别只在于proxy_pass转发的路径后是否带 “/“,</p>
<ul>
<li>针对不带<code>/</code>, 假如我们访问的url=<a href="http://www.test.com/test/test.php" target="_blank" rel="external">http://www.test.com/test/test.php</a>,<br>则通过nginx代理后，请求的路径访问地址为<a href="http://www.test.com/test/test.php" target="_blank" rel="external">http://www.test.com/test/test.php</a></li>
<li>针对带<code>/</code>, 假如我们访问的url=<a href="http://www.test.com/test/test.php" target="_blank" rel="external">http://www.test.com/test/test.php</a>,<br>则通过nginx代理后，请求的路径访问地址为<a href="http://www.test.com/test.php" target="_blank" rel="external">http://www.test.com/test.php</a></li>
<li>实现上述效果也可以通过rewrite来实现，代码如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">location ^~ /test/</div><div class="line">	&#123;</div><div class="line">	proxy_set_header Host www.test.com;</div><div class="line">	rewrite /test/(.+)$ /$1 break;</div><div class="line">	proxy_pass http://www.test.com;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="proxy-set-header-解析"><a href="#proxy-set-header-解析" class="headerlink" title="proxy_set_header 解析"></a>proxy_set_header 解析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">proxy_set_header</div><div class="line">Syntax: proxy_set_header field value</div><div class="line">Default: Host $proxy_host / Connection close</div><div class="line">Context: http / server / location</div><div class="line">Reference: proxy_set_header</div></pre></td></tr></table></figure>
<ul>
<li><p>当nginx作为反向代理使用，而如果后端服务器有防盗链或根据http请求头中的host字段来进行路由或判断功能的话，如nginx不重写请求头中的host字段，将会导致请求失败【默认反向代理服务器会向后端服务器发送请求，并且请求头中的host字段应为proxy_pass指令设置的服务器】</p>
</li>
<li><p>同理，X_Forward_For字段表示该条http请求是有谁发出的，如果反向代理服务器不重写该请求头的话，那么后端服务器在处理时会认为所有的请求都来在反向代理服务器，如果后端有防攻击策略的话，那么机器就无法访问了。</p>
</li>
<li><p>因此，一般我们用以下nginx中增加以下配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">proxy_set_header Host $http_host;</div><div class="line">proxy_set_header X-Forward-For $remote_addr;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>需要注意的是：如果Host请求头部没有出现在请求头中，则$http_host值为空，但是$host值为主域名。因此，一般而言，会用$host代替$http_host变量，从而避免http请求中丢失Host头部的情况下Host不被重写的失误。</p>
<h3 id="proxy-pass-与-tomcat-session丢失"><a href="#proxy-pass-与-tomcat-session丢失" class="headerlink" title="proxy_pass 与 tomcat session丢失"></a>proxy_pass 与 tomcat session丢失</h3><p>闲言少叙，直接看nginx修改前后的配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">location  / &#123;</div><div class="line">       proxy_pass http://10.44.15.43:8080/MP/;</div><div class="line">       proxy_redirect off;</div><div class="line">       proxy_set_header Host $host;</div><div class="line">       proxy_set_header X-Real-IP       $remote_addr;</div><div class="line">       proxy_set_header X-Forwarded-For  $proxy_add_x_forwarded_for;</div><div class="line">       &#125;</div></pre></td></tr></table></figure></p>
<p>修改后的配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">location  / &#123;</div><div class="line">    proxy_pass http://10.44.15.43:8080/MP/;</div><div class="line">    proxy_redirect off;</div><div class="line">    proxy_set_header Host $host;</div><div class="line">    proxy_set_header X-Real-IP       $remote_addr;</div><div class="line">    proxy_set_header X-Forwarded-For  $proxy_add_x_forwarded_for;</div><div class="line">    proxy_set_header   Cookie $http_cookie;                 </div><div class="line">    add_header From admin.weiwei.com.cn;</div><div class="line">    proxy_cookie_path /MP/ /;</div><div class="line">    chunked_transfer_encoding       off;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>问题分析：原来配置会导致cookie存储的位置不是基于“/”那么在第二次访问的时候会从新创建session，因此session中的信息丢失，因此修改cookeie的存储路径解决问题。</p>
<hr>
<p>您的鼓励是我写作最大的动力</p>
<p>俗话说，投资效率是最好的投资。 如果您感觉我的文章质量不错，读后收获很大，预计能为您提高 10% 的工作效率，不妨小额捐助我一下，让我有动力继续写出更多好文章。</p>
]]></content>
    
    <summary type="html">
    
      nginx proxy_pass 知识点
    
    </summary>
    
    
      <category term="nginx" scheme="https://t1ger.github.io/tags/nginx/"/>
    
  </entry>
  
</feed>
